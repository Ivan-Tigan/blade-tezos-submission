<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharpPlus</name></assembly>
<members>
<member name="M:FSharpPlus.Option.ofPair``1(System.Boolean,``0)">
 <summary>Converts pair of bool and value to Option.</summary>
 <remarks>Useful for handling C# try pattern with `out` parameter. E.g. `Int.TryParse` or `Dictionary.TryGetValue`.</remarks>
 <param name="pair">Pair of bool and value.</param>
 <returns><c>Some</c> if bool is `true`, <c>None</c> otherwise.</returns>
</member>
<member name="M:FSharpPlus.Option.protect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Creates a safe version of the supplied function, which returns an option&lt;&apos;U&gt; instead of throwing exceptions.
</summary>
</member>
<member name="M:FSharpPlus.Option.ofResult``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary>Converts a Result to an option.</summary>
 <remarks>The error value (if any) is lost.</remarks>
 <param name="source">The Result value.</param>
 <returns>The resulting option value.</returns>
</member>
<member name="M:FSharpPlus.Option.toResultWith``2(``0,Microsoft.FSharp.Core.FSharpOption{``1})">
 <summary>Converts an option to a Result.</summary>
 <param name="errorValue">The error value to be used in case of None.</param>
 <param name="source">The option value.</param>
 <returns>The resulting Result value.</returns>
</member>
<member name="M:FSharpPlus.Option.toResult``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Converts an option to a Result.</summary>
 <param name="source">The option value.</param>
 <returns>The resulting Result value.</returns>
</member>
<member name="M:FSharpPlus.Option.zip``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
 <summary>If both value are Some, returns both of them tupled. Otherwise it returns None.</summary>
 <param name="x">The first value.</param>
 <param name="y">The second value.</param>
 <returns>The resulting option.</returns>
</member>
<member name="M:FSharpPlus.Option.unzip``2(Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}})">
 <summary>If value is Some, returns both of them tupled. Otherwise it returns None tupled.</summary>
 <param name="v">The value.</param>
 <returns>The resulting tuple.</returns>
</member>
<member name="M:FSharpPlus.Option.apply``2(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Applies an option value to an option function.</summary>
 <param name="f">The option function.</param>
 <param name="x">The option value.</param>
 <returns>An option of the function applied to the value, or <c>None</c> if either the function or the value is <c>None</c>.</returns>
</member>
<member name="T:FSharpPlus.Option">
<summary>
 Additional operations on Option
</summary>
</member>
<member name="M:FSharpPlus.Nullable.toList``1(System.Nullable{``0})">
 <summary>Converts a Nullable to a list with 0 or 1 items.</summary>
 <param name="n">The Nullable value.</param>
 <returns>A list that contains the value in the Nullable if there is one, or an empty list.</returns>
</member>
<member name="M:FSharpPlus.Nullable.toArray``1(System.Nullable{``0})">
 <summary>Converts a Nullable to an array with 0 or 1 items.</summary>
 <param name="n">The Nullable value.</param>
 <returns>An array that contains the value in the Nullable if there is one, or an empty array.</returns>
</member>
<member name="M:FSharpPlus.Nullable.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Nullable{``0})">
 <summary>Returns whether a Nullable is empty or its value passes the given predicate. Like exists, but returns true when there is no value.</summary>
 <param name="pred">Function to test against the inner value.</param>
 <param name="n">The Nullable value.</param>
 <returns>True if the Nullable is empty or the value matches the predicate, false otherwise.</returns>
</member>
<member name="M:FSharpPlus.Nullable.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1,System.Nullable{``0})">
 <summary>Fold, but the update function has reversed arguments.</summary>
 <param name="f">A function to update the state data when given a value from the Nullable.</param>
 <param name="state">The initial state.</param>
 <param name="n">The Nullable value.</param>
 <returns>The new state if the Nullable contained a value, the original state otherwise.</returns>
</member>
<member name="M:FSharpPlus.Nullable.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Nullable{``1})">
 <summary>Updates state data with an update function and the value from a Nullable if it has one.</summary>
 <param name="f">A function to update the state data when given a value from the Nullable.</param>
 <param name="state">The initial state.</param>
 <param name="n">The Nullable value.</param>
 <returns>The new state if the Nullable contained a value, the original state otherwise.</returns>
</member>
<member name="M:FSharpPlus.Nullable.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Nullable{``0})">
 <summary>Filters the value in a Nullable with the given predicate.</summary>
 <param name="pred">Function that returns whether the value in the Nullable should remain.</param>
 <param name="n">The Nullable value.</param>
 <returns>The original Nullable value if the predicate matched the value, empty Nullable otherwise.</returns>
</member>
<member name="M:FSharpPlus.Nullable.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Nullable{``0})">
 <summary>Returns whether a Nullable contains a value for which the given predicate returns true.</summary>
 <param name="pred">Function to test against the inner value.</param>
 <param name="n">The Nullable value.</param>
 <returns>True if the Nullable contains a value that matches the predicate, false otherwise.</returns>
</member>
<member name="M:FSharpPlus.Nullable.defaultWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.Nullable{``0})">
 <summary>Returns the value inside a Nullable if it has one, otherwise returns the result of evaluating defThunk.</summary>
 <param name="defThunk">The function that returns a default value.</param>
 <param name="n">The Nullable value.</param>
 <returns>The value inside the Nullable or the result of defThunk.</returns>
</member>
<member name="M:FSharpPlus.Nullable.defaultValue``1(``0,System.Nullable{``0})">
 <summary>Returns the value inside a Nullable if it has one, otherwise returns defValue.</summary>
 <param name="defValue">The value to use if the Nullable does not have a value.</param>
 <param name="n">The Nullable value.</param>
 <returns>The value inside the Nullable or defValue.</returns>
</member>
<member name="M:FSharpPlus.Nullable.count``1(System.Nullable{``0})">
 <summary>Returns the number of values in the Nullable (0 or 1).</summary>
 <param name="n">The Nullable value.</param>
 <returns>1 if the Nullable has a value, 0 otherwise.</returns>
</member>
<member name="M:FSharpPlus.Nullable.isNull``1(System.Nullable{``0})">
 <summary>Returns whether a Nullable is empty.</summary>
 <param name="n">The Nullable value.</param>
 <returns>True if the Nullable does not have a value, false otherwise.</returns>
</member>
<member name="M:FSharpPlus.Nullable.hasValue``1(System.Nullable{``0})">
 <summary>Returns whether a Nullable has a value.</summary>
 <param name="n">The Nullable value.</param>
 <returns>True if the Nullable has a value, false otherwise.</returns>
</member>
<member name="M:FSharpPlus.Nullable.iter``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Nullable{``0})">
 <summary>Invokes a side-effect function to the value of a Nullable if present and ignores the result.</summary>
 <param name="f">The function to apply to the value of a Nullable.</param>
 <param name="n">The Nullable value.</param>
</member>
<member name="M:FSharpPlus.Nullable.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Nullable{``0})">
 <summary>Transforms the value inside a Nullable by using a specified mapping function.</summary>
 <param name="f">The value mapping function.</param>
 <param name="n">The Nullable value.</param>
</member>
<member name="M:FSharpPlus.Nullable.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``1}},System.Nullable{``0})">
 <summary>Monadic Bind; Transforms the value inside a Nullable to a Nullable using a specified binding function.</summary>
 <param name="f">The value binding function.</param>
 <param name="n">The Nullable value.</param>
</member>
<member name="T:FSharpPlus.Nullable">
<summary>
 Additional operations on Nullable
</summary>
</member>
<member name="M:FSharpPlus.Result.partition``2(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpResult{``0,``1}})">
 <summary>
 Creates two lists by classifying the values depending on whether they were wrapped with Ok or Error.
 </summary>
 <returns>
 A tuple with both resulting lists, Oks are in the first list.
 </returns>
</member>
<member name="M:FSharpPlus.Result.ofChoice``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Creates a Result&lt;&apos;T,&apos;Error&gt; from a Choice&lt;&apos;T,&apos;Error&gt;.
</summary>
</member>
<member name="M:FSharpPlus.Result.toChoice``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
<summary>
 Converts a Result&lt;&apos;T,&apos;Error&gt; to a Choice&lt;&apos;T,&apos;Error&gt;.
</summary>
</member>
<member name="M:FSharpPlus.Result.defaultWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpResult{``1,``0})">
<summary>
 Extracts the Ok value or applies the compensation function over the Error.
</summary>
</member>
<member name="M:FSharpPlus.Result.defaultValue``2(``0,Microsoft.FSharp.Core.FSharpResult{``0,``1})">
<summary>
 Extracts the Ok value or use the supplied default value when it&apos;s an Error.
</summary>
</member>
<member name="M:FSharpPlus.Result.get``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
<summary>
 Gets the &apos;Ok&apos; value. If it&apos;s an &apos;Error&apos; this function will throw an exception.
</summary>
</member>
<member name="M:FSharpPlus.Result.protect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Creates a safe version of the supplied function, which returns a Result&lt;&apos;U,exn&gt; instead of throwing exceptions.
</summary>
</member>
<member name="M:FSharpPlus.Result.either``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpResult{``0,``2})">
 <summary>Extracts a value from either side of a Result.</summary>
 <param name="fOk">Function to be applied to source, if it contains an Ok value.</param>
 <param name="fError">Function to be applied to source, if it contains an Error value.</param>
 <param name="source">The source value, containing an Ok or an Error.</param>
 <returns>The result of applying either functions.</returns>
</member>
<member name="M:FSharpPlus.Result.bindError``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpResult{``1,``2}},Microsoft.FSharp.Core.FSharpResult{``1,``0})">
 <summary>If the input value is an Ok leaves it unchanged, otherwise maps the Error value and flattens the resulting nested Result.</summary>
 <param name="binder">A function that takes the error and transforms it into a result.</param>
 <param name="source">The source input value.</param>
 <returns>A result of the output type of the binder.</returns>
</member>
<member name="M:FSharpPlus.Result.flatten``2(Microsoft.FSharp.Core.FSharpResult{Microsoft.FSharp.Core.FSharpResult{``0,``1},``1})">
 <summary>Flattens two nested Results.</summary>
 <param name="source">The nested Results.</param>
 <returns>A single Ok of the value when it was nested with OKs, or the Error.</returns>
 <remarks><c>flatten</c> is equivalent to <c>bind id</c>.</remarks>
</member>
<member name="M:FSharpPlus.Result.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Core.FSharpResult{``0,``4},Microsoft.FSharp.Core.FSharpResult{``1,``4},Microsoft.FSharp.Core.FSharpResult{``2,``4})">
 <summary>Creates a Result value from three Result values, using a function to combine them.</summary>
 <param name="f">The mapping function.</param>
 <param name="x">The first Result value.</param>
 <param name="y">The second Result value.</param>
 <param name="z">The third Result value.</param>

 <returns>The combined value, or the first Error.</returns>
</member>
<member name="M:FSharpPlus.Result.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpResult{``0,``3},Microsoft.FSharp.Core.FSharpResult{``1,``3})">
 <summary>Creates a Result value from a pair of Result values, using a function to combine them.</summary>
 <param name="f">The mapping function.</param>
 <param name="x">The first Result value.</param>
 <param name="y">The second Result value.</param>

 <returns>The combined value, or the first Error.</returns>
</member>
<member name="M:FSharpPlus.Result.apply``3(Microsoft.FSharp.Core.FSharpResult{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2},Microsoft.FSharp.Core.FSharpResult{``0,``2})">
<summary>
 Applies the wrapped value to the wrapped function when both are Ok and returns a wrapped result or the first Error.
 &lt;param name=&quot;f&quot;&gt;The function wrapped in an Ok or an Error.&lt;/param&gt;
 &lt;param name=&quot;x&quot;&gt;The value wrapped in an Ok or an Error.&lt;/param&gt;
 &lt;returns&gt;An Ok of the function applied to the value, or the first &lt;c&gt;Error&lt;/c&gt; if either the function or the value is &lt;c&gt;Error&lt;/c&gt;.&lt;/returns&gt;
</summary>
</member>
<member name="M:FSharpPlus.Result.throw``2(``0)">
<summary>
 Creates an Error With the supplied value.
</summary>
</member>
<member name="M:FSharpPlus.Result.result``2(``0)">
<summary>
 Creates an Ok with the supplied value.
</summary>
</member>
<member name="T:FSharpPlus.Result">
<summary>
 Additional operations on Result&lt;&apos;T,&apos;Error&gt;
</summary>
</member>
<member name="M:FSharpPlus.Choice.protect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Creates a safe version of the supplied function, which returns a Choice&lt;&apos;U,exn&gt; instead of throwing exceptions.
</summary>
</member>
<member name="M:FSharpPlus.Choice.either``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
 <summary>Extracts a value from either side of a Choice.</summary>
 <param name="fChoice1Of2">Function to be applied to source, if it contains a Choice1Of2 value.</param>
 <param name="fChoice2Of2">Function to be applied to source, if it contains a Choice2Of2 value.</param>
 <param name="source">The source value, containing a Choice1Of2 or a Choice2Of2.</param>
 <returns>The result of applying either functions.</returns>
</member>
<member name="M:FSharpPlus.Choice.bindChoice2Of2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``1,``0})">
 <summary>If the input value is a Choice1Of2 leaves it unchanged, otherwise maps the value on the Choice2Of2 and flattens the resulting nested Choice.</summary>
 <param name="binder">A function that takes the value of type T and transforms it into a Choice containing (potentially) a value of type U.</param>
 <param name="source">The source input value.</param>
 <returns>A result of the output type of the binder.</returns>
</member>
<member name="M:FSharpPlus.Choice.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
 <summary>If the input value is a Choice2Of2 leaves it unchanged, otherwise maps the value on the Choice1Of2 and flattens the resulting nested Choice.</summary>
 <param name="binder">A function that takes the value of type T and transforms it into a Choice containing (potentially) a value of type U.</param>
 <param name="source">The source input value.</param>
 <returns>A result of the output type of the binder.</returns>
</member>
<member name="M:FSharpPlus.Choice.flatten``2(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpChoice{``0,``1},``1})">
 <summary>Flattens two nested Choice.</summary>
 <param name="source">The nested Choice.</param>
 <returns>A single Choice1Of2 of the value when it was nested with Choice1Of2s, or the Choice2Of2.</returns>
 <remarks><c>flatten</c> is equivalent to <c>bind id</c>.</remarks>
</member>
<member name="M:FSharpPlus.Choice.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Core.FSharpChoice{``0,``4},Microsoft.FSharp.Core.FSharpChoice{``1,``4},Microsoft.FSharp.Core.FSharpChoice{``2,``4})">
 <summary>Creates a Choice value from three of Choice values, using a function to combine the Choice1Of2 values.</summary>
 <param name="mapping">A function to apply to the Choice1Of2 values.</param>
 <param name="x">The first Choice value.</param>
 <param name="y">The second Choice value.</param>
 <param name="z">The third Choice value.</param>

 <returns>The combined value, or the first Choice2Of2.</returns>
</member>
<member name="M:FSharpPlus.Choice.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``3},Microsoft.FSharp.Core.FSharpChoice{``1,``3})">
 <summary>Creates a Choice value from a pair of Choice values, using a function to combine the Choice1Of2 values.</summary>
 <param name="mapping">A function to apply to the Choice1Of2 values.</param>
 <param name="x">The first Choice value.</param>
 <param name="y">The second Choice value.</param>

 <returns>The combined value, or the first Choice2Of2.</returns>
</member>
<member name="M:FSharpPlus.Choice.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
 <summary>Maps the value on the Choice1Of2 if any.</summary>
 <param name="mapping">A function to apply to the Choice1Of2 value.</param>
 <param name="source">The source input value.</param>
 <returns>A Choice1Of2 of the input value after applying the mapping function, or the original Choice2Of2 value if the input is Choice2Of2.</returns>
</member>
<member name="M:FSharpPlus.Choice.apply``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Applies the wrapped value to the wrapped function when both are Choice1Of2 and returns a wrapped result or the first Choice2Of2.
 This is as if Choice1Of2 respresents a Success value and Choice2Of2 a Failure.
 &lt;param name=&quot;f&quot;&gt;The function wrapped in a Choice1Of2 or a Choice2Of2.&lt;/param&gt;
 &lt;param name=&quot;x&quot;&gt;The value wrapped in a Choice1Of2 or a Choice2Of2.&lt;/param&gt;
 &lt;returns&gt;A Choice1Of2 of the function applied to the value, or the first &lt;c&gt;Choice2Of2&lt;/c&gt; if either the function or the value is &lt;c&gt;Choice2Of2&lt;/c&gt;.&lt;/returns&gt;
</summary>
</member>
<member name="M:FSharpPlus.Choice.throw``2(``0)">
<summary>
 Creates a Choice2Of2 with the supplied value.
</summary>
</member>
<member name="M:FSharpPlus.Choice.result``2(``0)">
<summary>
 Creates a Choice1Of2 with the supplied value.
</summary>
</member>
<member name="T:FSharpPlus.Choice">
<summary>
 Additional operations on Choice
</summary>
</member>
<member name="M:FSharpPlus.Seq.choosei``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Choose with access to the index</summary>
 <param name="mapping">The mapping function, taking index and element as parameters.</param>
 <param name="source">The input seq.</param>

 <returns>Seq with values x for each List value where the function returns Some(x).</returns>
</member>
<member name="M:FSharpPlus.Seq.tryFindSliceIndex``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Gets the index of the first occurrence of the specified slice in the source.
 Returns <c>None</c> if not found.
 </summary>
 <remarks>
 It is assumed that 1) the slice is finite and 2) either the source is finite or actually contains the slice, otherwise it will not return forever.
 The slice will always be iterated to the end.
 The source will be iterated until the slice is found or it reaches the end.
 </remarks>
 <returns>
 The index of the slice or <c>None</c>.
 </returns>
</member>
<member name="M:FSharpPlus.Seq.findSliceIndex``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Gets the index of the first occurrence of the specified slice in the source.
 </summary>
 <remarks>
 It is assumed that 1) the slice is finite and 2) either the source is finite or actually contains the slice, otherwise it will not return forever.
 The slice will always be iterated to the end.
 The source will be iterated until the slice is found or it reaches the end.
 </remarks>
 <exception cref="System.ArgumentException">
 Thrown when the slice was not found in the sequence.
 </exception>
 <returns>
 The index of the slice.
 </returns>
</member>
<member name="M:FSharpPlus.Seq.toIReadOnlyList``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Converts a seq to an IReadOnlyList (from System.Collections.Generic).</summary>
 <param name="source">The seq source</param>
 <returns>The seq converted to a System.Collections.Generic.IReadOnlyList</returns>
</member>
<member name="M:FSharpPlus.Seq.replicate``1(System.Int32,``0)">
 <summary>
 Creates a sequence by replicating the given initial value count times.
 </summary>
 <remarks>
 Note: this function has since been added to FSharpCore, so effectively
 overrides it. It will be removed in next major release of FSharpPlus.
 </remarks>
</member>
<member name="M:FSharpPlus.Seq.drop``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that drops N elements of the original sequence and then yields the
 remaining elements of the sequence.</summary>
 <remarks>When count exceeds the number of elements in the sequence it
 returns an empty sequence instead of throwing an exception.</remarks>
 <param name="count">The number of items to drop.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Seq.replace``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Replaces a subsequence of the source seq with the given replacement seq.
</summary>
</member>
<member name="M:FSharpPlus.Seq.split``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Creates a sequence of sequences by splitting the source sequence on any of the given separators.
</summary>
</member>
<member name="M:FSharpPlus.Seq.intercalate``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Inserts a separator between each element in the source sequence.
</summary>
</member>
<member name="M:FSharpPlus.Seq.intersperse``1(``0,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Inserts a separator element between each element in the source seq.
http://codebetter.com/matthewpodwysocki/2009/05/06/functionally-implementing-intersperse/
</summary>
</member>
<member name="M:FSharpPlus.Seq.chunkBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Chunks the seq up into groups with the same projected key by applying
 the key-generating projection function to each element and yielding a sequence of 
 keys tupled with values.
 </summary>

 <remarks>
 Each key is tupled with an array of all adjacent elements that match 
 to the key, therefore keys are not unique but can't be adjacent
 as each time the key changes a new group is yield.
 
 The ordering of the original sequence is respected.
 </remarks>

 <param name="projection">A function that transforms an element of the sequence into a comparable key.</param>
 <param name="source">The input seq.</param>

 <returns>The resulting sequence of keys tupled with an array of matching values</returns>
</member>
<member name="M:FSharpPlus.Seq.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.IEnumerable{``0},``1)">
 <summary>
 Applies a function to each element of the collection, starting from the end,
 threading an accumulator argument through the computation.
 </summary>
 <remarks>
 Note: this function has since been added to FSharpCore, so effectively
 overrides it. It will be removed in next major release of FSharpPlus.
 </remarks>
</member>
<member name="M:FSharpPlus.Seq.lift3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Combines values from three seq and calls a mapping function on this combination.</summary>
 <param name="f">Mapping function taking three element combination as input.</param>
 <param name="x1">First seq.</param>
 <param name="x2">Second seq.</param>
 <param name="x3">Third seq.</param>

 <returns>Seq with values returned from mapping function.</returns>
</member>
<member name="M:FSharpPlus.Seq.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Combines all values from the first seq with the second, using the supplied mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Seq.apply``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a sequence of functions to a sequence of values and concatenates them.</summary>
 <param name="f">The seq of functions.</param>
 <param name="x">The seq of values.</param>
 <returns>A seq concatenating the results from applying each function to each value.</returns>
 
 <example>
 <code>
 > Seq.apply [double; triple] [1; 2; 3];;  
 val it : seq&lt;int&gt; = seq [2; 4; 6; 3; ...]
 </code>
 </example>
</member>
<member name="M:FSharpPlus.Seq.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Collections.Generic.IEnumerable{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to each element of the sequence and concatenates the results.</summary>

 <remarks>Remember sequence is lazy, effects are delayed until it is enumerated.</remarks>
 <remarks>This is the same as Seq.collect but the type of the mapping function is not flexible.</remarks>

 <param name="mapping">A function to transform elements of the input sequence into the sequences
 that will then be concatenated.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="T:FSharpPlus.Seq">
<summary>
 Additional operations on Seq
</summary>
</member>
<member name="M:FSharpPlus.IList.toIReadOnlyList``1(System.Collections.Generic.IList{``0})">
 <summary>Converts an IList to an IReadOnlyList (from System.Collections.Generic).</summary>
 <param name="source">The System.Collections.Generic.IList</param>
 <returns>The list converted to a System.Collections.Generic.IReadOnlyList</returns>
</member>
<member name="T:FSharpPlus.IList">
<summary>
 Additional operations IList&lt;&apos;T&gt;
</summary>
</member>
<member name="M:FSharpPlus.List.setAt``1(System.Int32,``0,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Updates the value of an item in a list</summary>
 <param name="i">The index of the item to update</param>
 <param name="x">The new value of the item</param>
 <param name="lst">The input list</param>

 <returns>A new list with the updated element</returns>
</member>
<member name="M:FSharpPlus.List.removeAt``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Attempts to remove an item from a list.</summary>
 <param name="i">The index of the item to remove </param>
 <param name="lst">The input list</param>
 
 <returns>For invalid indexes, the input list.  Otherwise, a new list with the item removed.</returns>
</member>
<member name="M:FSharpPlus.List.choosei``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Same as choose but with access to the index.</summary>
 <param name="mapping">The mapping function, taking index and element as parameters.</param>
 <param name="source">The input list.</param>

 <returns>List with values x for each List value where the function returns Some(x).</returns>
</member>
<member name="M:FSharpPlus.List.zipShortest``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>
 Zip safely two lists. If one list is shorter, excess elements are discarded from the right end of the longer list. 
 </summary>
 <param name="list1">First input list.</param>
 <param name="list2">Second input list.</param>
 <returns>List with corresponding pairs of input lists.</returns>
</member>
<member name="M:FSharpPlus.List.map2Shortest``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Safely build a new list whose elements are the results of applying the given function
 to each of the elements of the two lists pairwise.</summary>
 <remark>If one list is shorter, excess elements are discarded from the right end of the longer list.</remark>
</member>
<member name="M:FSharpPlus.List.partitionMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Creates two lists by applying the mapping function to each element in the list
 and classifying the transformed values depending on whether they were wrapped with Choice1Of2 or Choice2Of2.
 </summary>
 <returns>
 A tuple with both resulting lists.
 </returns>
</member>
<member name="M:FSharpPlus.List.tryFindSliceIndex``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Gets the index of the first occurrence of the specified slice in the source.
 Returns <c>None</c> if not found.
 </summary>
 <returns>
 The index of the slice or <c>None</c>.
 </returns>
</member>
<member name="M:FSharpPlus.List.findSliceIndex``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>
 Gets the index of the first occurrence of the specified slice in the source.
 </summary>
 <exception cref="System.ArgumentException">
 Thrown when the slice was not found in the sequence.
 </exception>
 <returns>
 The index of the slice.
 </returns>
</member>
<member name="M:FSharpPlus.List.toIReadOnlyList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Converts a list to an IReadOnlyList (from System.Collections.Generic).</summary>
 <param name="source">The list source</param>
 <returns>The list converted to a System.Collections.Generic.IReadOnlyList</returns>
</member>
<member name="M:FSharpPlus.List.replace``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Replaces a subsequence of the source list with the given replacement list.
</summary>
</member>
<member name="M:FSharpPlus.List.split``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpList{``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Creates a sequence of lists by splitting the source list on any of the given separators.
</summary>
</member>
<member name="M:FSharpPlus.List.intersperse``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Inserts a separator element between each element in the source list.
</summary>
</member>
<member name="M:FSharpPlus.List.intercalate``1(Microsoft.FSharp.Collections.FSharpList{``0},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Concatenates all elements, using the specified separator between each element.
</summary>
</member>
<member name="M:FSharpPlus.List.drop``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a list that drops N elements of the original list and then yields the
 remaining elements of the list.</summary>
 <remarks>When count exceeds the number of elements in the list it
 returns an empty list instead of throwing an exception.</remarks>
 <param name="count">The number of items to drop.</param>
 <param name="source">The input list.</param>

 <returns>The result list.</returns>
</member>
<member name="M:FSharpPlus.List.tails``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Returns a list with all possible tails of the source list.
</summary>
</member>
<member name="M:FSharpPlus.List.lift3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Collections.FSharpList{``2},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Combines values from three list and calls a mapping function on this combination.</summary>
 <param name="f">Mapping function taking three element combination as input.</param>
 <param name="x1">First list.</param>
 <param name="x2">Second list.</param>
 <param name="x3">Third list.</param>

 <returns>List with values returned from mapping function.</returns>
</member>
<member name="M:FSharpPlus.List.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Combines all values from the first list with the second, using the supplied mapping function.
</summary>
</member>
<member name="M:FSharpPlus.List.apply``2(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies a list of functions to a list of values and concatenates them</summary>
 <param name="f">The list of functions.</param>
 <param name="x">The list of values.</param>
 <returns>A concatenated list of the result lists of applying each function to each value</returns>
 
 <example>
 <code>
 > List.apply [double; triple] [1; 2; 3];;  
 val it : int list = [2; 4; 6; 3; 6; 9]
 </code>
 </example>
</member>
<member name="M:FSharpPlus.List.cons``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Adds an element to the beginning of the given list</summary>
 <param name="x">The element to add</param>
 <param name="list">The list to add to</param>
 <returns>A concatenated list of the result lists of applying each function to each value</returns>
</member>
<member name="M:FSharpPlus.List.singleton``1(``0)">
<summary>
 Creates a list with a single element.
</summary>
</member>
<member name="T:FSharpPlus.List">
<summary>
 Additional operations on List
</summary>
</member>
<member name="M:FSharpPlus.Array.choosei``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},``0[])">
 <summary>Same as choose but with access to the index.</summary>
 <param name="mapping">The mapping function, taking index and element as parameters.</param>
 <param name="source">The input array.</param>

 <returns>Array with values x for each Array value where the function returns Some(x).</returns>
</member>
<member name="M:FSharpPlus.Array.zipShortest``2(``0[],``1[])">
 <summary>
 Zip safely two arrays. If one array is shorter, excess elements are discarded from the right end of the longer array. 
 </summary>
 <param name="a1">First input array.</param>
 <param name="a2">Second input array.</param>
 <returns>Array with corresponding pairs of input arrays.</returns>
</member>
<member name="M:FSharpPlus.Array.map2Shortest``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0[],``1[])">
 <summary>Safely build a new array whose elements are the results of applying the given function
 to each of the elements of the two arrays pairwise.</summary>
 <remark>If one array is shorter, excess elements are discarded from the right end of the longer array.</remark>
</member>
<member name="M:FSharpPlus.Array.partitionMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},``0[])">
 <summary>
 Creates two arrays by applying the mapper function to each element in the array
 and classifies the transformed values depending on whether they were wrapped with Choice1Of2 or Choice2Of2.
 </summary>
 <returns>
 A tuple with both resulting arrays.
 </returns>
</member>
<member name="M:FSharpPlus.Array.tryFindSliceIndex``1(``0[],``0[])">
 <summary>
 Returns the index of the first occurrence of the specified slice in the source.
 Returns <c>None</c> if not found.
 </summary>
 <returns>
 The index of the slice or <c>None</c>.
 </returns>
</member>
<member name="M:FSharpPlus.Array.findSliceIndex``1(``0[],``0[])">
 <summary>
 Returns the index of the first occurrence of the specified slice in the source.
 </summary>
 <exception cref="System.ArgumentException">
 Thrown when the slice was not found in the sequence.
 </exception>
 <returns>
 The index of the slice.
 </returns>
 <summary>
 Returns the index of the first occurrence of the specified slice in the source.
 Note: this is unsafe and will throw ArgumentException when the specified slice is not found.
 </summary>
 <returns>
 The index of the slice or <c>None</c>.
 </returns>
</member>
<member name="M:FSharpPlus.Array.replace``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},``0[])">
<summary>
 Replaces a subsequence of the source array with the given replacement array.
</summary>
</member>
<member name="M:FSharpPlus.Array.split``1(System.Collections.Generic.IEnumerable{``0[]},``0[])">
<summary>
 Creates a sequence of arrays by splitting the source array on any of the given separators.
</summary>
</member>
<member name="M:FSharpPlus.Array.intersperse``1(``0,``0[])">
<summary>
 Inserts a separator element between each element in the source array.
</summary>
</member>
<member name="M:FSharpPlus.Array.intercalate``1(``0[],System.Collections.Generic.IEnumerable{``0[]})">
<summary>
 Concatenates all elements, using the specified separator between each element.
</summary>
</member>
<member name="M:FSharpPlus.Array.lift3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``0[],``1[],``2[])">
 <summary>Combines all values from three arrays and calls a mapping function on this combination.</summary>
 <param name="mapping">Mapping function taking three element combination as input.</param>
 <param name="list1">First array.</param>
 <param name="list2">Second array.</param>
 <param name="list3">Third array.</param>

 <returns>Array with values returned from mapping function.</returns>
</member>
<member name="M:FSharpPlus.Array.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0[],``1[])">
<summary>
 Combines all values from the first array with the second, using the supplied mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Array.apply``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1}[],``0[])">
 <summary>Applies an array of functions to an array of values and concatenates them.</summary>
 <param name="f">The array of functions.</param>
 <param name="x">The array of values.</param>
 <returns>A concatenated array of the resulting arrays from applying each function to each value</returns>
 
 <example>
 <code>
 > Array.apply [|double; triple|] [|1; 2; 3|];;  
 val it : int [] = [|2; 4; 6; 3; 6; 9|]
 </code>
 </example>
</member>
<member name="T:FSharpPlus.Array">
<summary>
 Additional operations on Array
</summary>
</member>
<member name="M:FSharpPlus.ResizeArray.zipShortest``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
 <summary>
 Zip safely two ResizeArrays. If one ResizeArray is shorter, excess elements are discarded from the right end of the longer ResizeArray. 
 </summary>
 <param name="a1">First input ResizeArray.</param>
 <param name="a2">Second input ResizeArray.</param>
 <returns>ResizeArray with corresponding pairs of input ResizeArrays.</returns>
</member>
<member name="M:FSharpPlus.ResizeArray.map2Shortest``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
 <summary>Safely build a new ResizeArray whose elements are the results of applying the given function
 to each of the elements of the two ResizeArrays pairwise.</summary>
 <remark>If one array is shorter, excess elements are discarded from the right end of the longer array.</remark>
</member>
<member name="M:FSharpPlus.ResizeArray.partitionMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},``0[])">
 <summary>
 Creates two arrays by applying the mapper function to each element in the array
 and classifying the transformed values depending on whether they were wrapped with Choice1Of2 or Choice2Of2.
 </summary>
 <returns>
 A tuple with both resulting arrays.
 </returns>
</member>
<member name="M:FSharpPlus.ResizeArray.tryFindSliceIndex``1(``0[],``0[])">
 <summary>
 Returns the index of the first occurrence of the specified slice in the source.
 Returns <c>None</c> if not found.
 </summary>
 <returns>
 The index of the slice or <c>None</c>.
 </returns>
</member>
<member name="M:FSharpPlus.ResizeArray.findSliceIndex``1(``0[],``0[])">
 <summary>
 Returns the index of the first occurrence of the specified slice in the source.
 </summary>
 <exception cref="System.ArgumentException">
 Thrown when the slice was not found in the sequence.
 </exception>
 <returns>
 The index of the slice.
 </returns>
</member>
<member name="M:FSharpPlus.ResizeArray.replace``1(``0[],``0[],``0[])">
<summary>
 Replaces a subsequence of the source array with the given replacement array.
</summary>
</member>
<member name="M:FSharpPlus.ResizeArray.split``1(System.Collections.Generic.IEnumerable{``0[]},``0[])">
<summary>
 Creates a sequence of arrays by splitting the source array on any of the given separators.
</summary>
</member>
<member name="M:FSharpPlus.ResizeArray.intersperse``1(``0,``0[])">
<summary>
 Inserts a separator element between each element in the source ResizeArray.
</summary>
</member>
<member name="M:FSharpPlus.ResizeArray.intercalate``1(``0[],System.Collections.Generic.IEnumerable{``0[]})">
<summary>
 Concatenates all elements, using the specified separator between each element.
</summary>
</member>
<member name="M:FSharpPlus.ResizeArray.lift3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},System.Collections.Generic.List{``2},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
 <summary>Combines values from three ResizeArrays and calls a mapping function on this combination.</summary>
 <param name="mapping">Mapping function taking three element combination as input.</param>
 <param name="x1">First ResizeArray.</param>
 <param name="x2">Second ResizeArray.</param>
 <param name="x3">Third ResizeArray.</param>

 <returns>ResizeArray with values returned from mapping function.</returns>
</member>
<member name="M:FSharpPlus.ResizeArray.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Combines all values from the first ResizeArray with the second, using the supplied mapping function.
</summary>
</member>
<member name="M:FSharpPlus.ResizeArray.apply``2(System.Collections.Generic.List{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.List{``0})">
 <summary>Applies a ResizeArray of functions to a ResizeArray of values and concatenates them.</summary>
 <param name="f">The functions.</param>
 <param name="x">The values.</param>
 <returns>A concatenated list of the resulting ResizeArray after applying each function to each value.</returns>
 
 <example>
 <code>
 > List.apply [double; triple] [1; 2; 3];;  
 val it : int list = [2; 4; 6; 3; 6; 9]
 </code>
 </example>
</member>
<member name="M:FSharpPlus.ResizeArray.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
 <summary>Builds a new ResizeArray whose elements are the results of applying the given function
 to each of the elements of the ResizeArray.</summary>

 <param name="mapping">A function to transform items from the input ResizeArray.</param>
 <param name="source">The input ResizeArray.</param>

 <returns>The result ResizeArray.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input ResizeArray is null.</exception>
</member>
<member name="T:FSharpPlus.ResizeArray">
<summary>
 Additional operations on ResizeArray
</summary>
</member>
<member name="M:FSharpPlus.String.getBytes(System.Text.Encoding,System.String)">
<summary>
 Converts a string to a byte-array using the specified encoding.
</summary>
</member>
<member name="M:FSharpPlus.String.ofCodePoints(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>
 Converts the array of Int32 code-points (the actual Unicode Code Point number) to a string.
</summary>
</member>
<member name="M:FSharpPlus.String.toCodePoints(System.String)">
<summary>
 Converts the given string to an array of Int32 code-points (the actual Unicode Code Point number).
</summary>
</member>
<member name="M:FSharpPlus.String.tryFindSliceIndex(System.String,System.String)">
 <summary>
 Returns the index of the first occurrence of the specified slice in the source.
 Returns <c>None</c> if not found.
 </summary>
 <returns>
 The index of the slice or <c>None</c>.
 </returns>
</member>
<member name="M:FSharpPlus.String.findSliceIndex(System.String,System.String)">
 <summary>
 Returns the index of the first occurrence of the specified slice in the source.
 </summary>
 <exception cref="System.ArgumentException">
 Thrown when the slice was not found in the sequence.
 </exception>
 <returns>
 The index of the slice.
 </returns>
</member>
<member name="M:FSharpPlus.String.tryFindIndex(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 Tries to find the first index of the char in the substring which satisfies the given predicate.
</summary>
</member>
<member name="M:FSharpPlus.String.findIndex(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 Finds the first index of the char in the substring which satisfies the given predicate.
 
 Note: throws an ArgumentException when not found.
</summary>
</member>
<member name="M:FSharpPlus.String.drop(System.Int32,System.String)">
<summary>
 Returns a string that drops first N characters of the original string.
 When count exceeds the length of the string it returns an empty string.
</summary>
</member>
<member name="M:FSharpPlus.String.truncate(System.Int32,System.String)">
<summary>
 Returns a string that has at most N characters from the beginning of the original string.
 It returns the original string if it is shorter than count.
</summary>
</member>
<member name="M:FSharpPlus.String.tryLast(System.String)">
 <summary>Gets the last char of the string, or
 <c>None</c> if the string is empty.</summary>
</member>
<member name="M:FSharpPlus.String.tryHead(System.String)">
 <summary>Gets the first char of the string, or
 <c>None</c> if the string is empty.</summary>
</member>
<member name="M:FSharpPlus.String.skipWhile(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 Skips over chars from the source string while the given predicate is true.
</summary>
</member>
<member name="M:FSharpPlus.String.takeWhile(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 Takes chars from the source string while the given predicate is true.
</summary>
</member>
<member name="M:FSharpPlus.String.skip(System.Int32,System.String)">
<summary>
 (Unsafely) Skips over the first count chars in the string.
 Use `String.drop` for a safe version.
 
 Note: will throw System.ArgumentOutOfRangeException if you try to skip more than the
 number of chars in the string.
</summary>
</member>
<member name="M:FSharpPlus.String.take(System.Int32,System.String)">
<summary>
 (Unsafely) Takes the first count chars in the string.
 Use `String.truncate` for a safe version.
 
 Note: will throw System.ArgumentOutOfRangeException if you try to take more than the
 number of chars in the string.
</summary>
</member>
<member name="M:FSharpPlus.String.rev(System.String)">
<summary>
 Reverses the given string.
</summary>
</member>
<member name="M:FSharpPlus.String.tryItem(System.Int32,System.String)">
<summary>
 Returns the char (as an Option) at the given index in the source string,
 returning `None` if out of bounds.
</summary>
</member>
<member name="M:FSharpPlus.String.item(System.Int32,System.String)">
<summary>
 (Unsafely) Returns the char at the given index in the source string.
 
 This is a function wrapper for `source.[index]` method.
 
 Note: this is not exception safe, and will throw System.IndexOutOfRangeException when
 the given index is out of bounds.
</summary>
</member>
<member name="M:FSharpPlus.String.ofSeq(System.Collections.Generic.IEnumerable{System.Char})">
<summary>
 Converts a seq of chars to a String.
</summary>
</member>
<member name="M:FSharpPlus.String.toSeq(System.String)">
<summary>
 Converts the given string to a seq of chars.
</summary>
</member>
<member name="M:FSharpPlus.String.ofList(Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Converts a list of chars to a String.
</summary>
</member>
<member name="M:FSharpPlus.String.toList(System.String)">
<summary>
 Converts the given string to a list of chars.
</summary>
</member>
<member name="M:FSharpPlus.String.ofArray(System.Char[])">
<summary>
 Converts an array of chars to a String.
</summary>
</member>
<member name="M:FSharpPlus.String.toArray(System.String)">
<summary>
 Converts the given string to an array of chars.
</summary>
</member>
<member name="M:FSharpPlus.String.trimEnd(System.Collections.Generic.IEnumerable{System.Char},System.String)">
<summary>
 Removes all trailing occurrences of specified characters from the given string.
</summary>
</member>
<member name="M:FSharpPlus.String.trimStart(System.Collections.Generic.IEnumerable{System.Char},System.String)">
<summary>
 Removes all leading occurrences of specified characters from the given string.
</summary>
</member>
<member name="M:FSharpPlus.String.trim(System.Collections.Generic.IEnumerable{System.Char},System.String)">
<summary>
 Removes all leading and trailing occurrences of specified characters from the given string.
</summary>
</member>
<member name="M:FSharpPlus.String.padRightWith(System.Int32,System.Char,System.String)">
<summary>
 Pads the end of the given string with a specified character so that it has a specified total length.
</summary>
</member>
<member name="M:FSharpPlus.String.padRight(System.Int32,System.String)">
<summary>
 Pads the end of the given string with spaces so that it has a specified total length.
</summary>
</member>
<member name="M:FSharpPlus.String.padLeftWith(System.Int32,System.Char,System.String)">
<summary>
 Pads the beginning of the given string with a specified character so that it has a specified total length.
</summary>
</member>
<member name="M:FSharpPlus.String.padLeft(System.Int32,System.String)">
<summary>
 Pads the beginning of the given string with spaces so that it has a specified total length.
</summary>
</member>
<member name="M:FSharpPlus.String.removeDiacritics(System.String)">
<summary>
 Removes diacritics (accents) from the given source string.
 
 The approach uses `normalize` to split the input string into constituent glyphs
 (basically separating the &quot;base&quot; characters from the diacritics) and then scans
 the result and retains only the base characters. 
</summary>
</member>
<member name="M:FSharpPlus.String.normalize(System.Text.NormalizationForm,System.String)">
<summary>
 Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.
 
 This is a null safe function wrapper of the String.Normalize method.
</summary>
</member>
<member name="M:FSharpPlus.String.trimEndWhiteSpaces(System.String)">
<summary>
 Trims trailing white spaces -- function wrapper for String.TrimEnd method.
 
 Note this is distinct from trim which trims the given characters,
 not white spaces.
</summary>
</member>
<member name="M:FSharpPlus.String.trimStartWhiteSpaces(System.String)">
<summary>
 Trims leading white spaces -- function wrapper for String.TrimStart method.
 
 Note this is distinct from trim which trims the given characters,
 not white spaces.
</summary>
</member>
<member name="M:FSharpPlus.String.trimWhiteSpaces(System.String)">
<summary>
 Trims leading and trailing white spaces -- function wrapper for String.Trim method.
 
 Note this is distinct from trim which trims the given characters,
 not white spaces.
</summary>
</member>
<member name="M:FSharpPlus.String.toLower(System.String)">
<summary>
 Converts to lowercase -- nullsafe function wrapper for String.ToLowerInvariant method.
</summary>
</member>
<member name="M:FSharpPlus.String.toUpper(System.String)">
<summary>
 Converts to uppercase -- nullsafe function wrapper for String.ToUpperInvariant method.
</summary>
</member>
<member name="M:FSharpPlus.String.contains(System.Char,System.String)">
<summary>
 Does the source string contain the given character?
</summary>
</member>
<member name="M:FSharpPlus.String.endsWith(System.String,System.String)">
<summary>
 Does the source string end with the given subString? -- function wrapper for String.EndsWith method using InvariantCulture.
</summary>
</member>
<member name="M:FSharpPlus.String.startsWith(System.String,System.String)">
<summary>
 Does the source string start with the given subString? -- function wrapper for String.StartsWith method using InvariantCulture.
</summary>
</member>
<member name="M:FSharpPlus.String.isSubString(System.String,System.String)">
<summary>
 Does the source string contain the given subString? -- function wrapper for String.Contains method.
</summary>
</member>
<member name="M:FSharpPlus.String.replace(System.String,System.String,System.String)">
<summary>
 Replaces a substring with the given replacement string.
</summary>
</member>
<member name="M:FSharpPlus.String.split(System.Collections.Generic.IEnumerable{System.String},System.String)">
<summary>
 Creates a sequence of strings by splitting the srouce string on any of the given separators.
</summary>
</member>
<member name="M:FSharpPlus.String.intersperse(System.Char,System.String)">
<summary>
 Inserts a separator char between each char in the source string.
</summary>
</member>
<member name="M:FSharpPlus.String.intercalate(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Concatenates all elements, using the specified separator between each element.
</summary>
</member>
<member name="T:FSharpPlus.String">
<summary>
 Additional operations on String
</summary>
</member>
<member name="T:FSharpPlus.IReadOnlyCollection">
<summary>
 Additional operations on IReadOnlyCollection&lt;&apos;T&gt;
</summary>
</member>
<member name="M:FSharpPlus.IReadOnlyList.trySetItem``1(System.Int32,``0,System.Collections.Generic.IReadOnlyList{``0})">
<summary>
 Returns a new IReadOnlyList from a given IReadOnlyList, with replaced binding for index.
</summary>
</member>
<member name="T:FSharpPlus.IReadOnlyList">
<summary>
 Additional operations on ReadOnlyList&lt;&apos;T&gt;
</summary>
</member>
<member name="M:FSharpPlus.Lazy.apply``2(System.Lazy{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Lazy{``0})">
 <summary>Applies a Lazy value to a Lazy function.</summary>
 <param name="f">The Lazy function.</param>
 <param name="x">The Lazy value.</param>
 <returns>A Lazy value of the function applied to the value.</returns>
</member>
<member name="M:FSharpPlus.Lazy.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},System.Lazy{``0},System.Lazy{``1},System.Lazy{``2})">
 <summary>Creates a Lazy value from three Lazy values, using a function to combine them.</summary>
 <param name="mapping">The mapping function.</param>
 <param name="x">The first Lazy value.</param>
 <param name="y">The second Lazy value.</param>
 <param name="z">The third Lazy value.</param>

 <returns>The combined value.</returns>
</member>
<member name="M:FSharpPlus.Lazy.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Lazy{``0},System.Lazy{``1})">
 <summary>Creates a Lazy value from a pair of Lazy values, using a mapping function to combine them.</summary>
 <param name="mapping">The mapping function.</param>
 <param name="x">The first Lazy value.</param>
 <param name="y">The second Lazy value.</param>

 <returns>The combined value.</returns>
</member>
<member name="M:FSharpPlus.Lazy.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Lazy{``0})">
 <summary>Creates a Lazy value from another Lazy value, mapping through a function.</summary>
 <param name="mapping">The mapping function.</param>
 <param name="x">The Lazy value.</param>

 <returns>The mappeed value.</returns>
</member>
<member name="T:FSharpPlus.Lazy">
<summary>
 Additional operations on Lazy - delayed computations
</summary>
</member>
<member name="M:FSharpPlus.Map.choosei``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Same as chooseValues but with access to the key.</summary>
 <param name="f">The mapping function, taking key and element as parameters.</param>
 <param name="x">The input map.</param>

 <returns>Returns Map with values (k, v) for each Map value where the function returns Some(v).</returns>
</member>
<member name="M:FSharpPlus.Map.intersect``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
Returns the intersection of two maps, preferring values from the first in case of duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Map.intersectWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpMap{``1,``0},Microsoft.FSharp.Collections.FSharpMap{``1,``0})">
<summary>
 Returns the intersection of two maps, using the combiner function for duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Map.union``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Returns the union of two maps, preferring values from the first in case of duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Map.unionWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpMap{``1,``0},Microsoft.FSharp.Collections.FSharpMap{``1,``0})">
<summary>
 Returns the union of two maps, using the combiner function for duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Map.unzip``3(Microsoft.FSharp.Collections.FSharpMap{``0,System.Tuple{``1,``2}})">
 <summary>Splits a Map with tuple pair values to two separate Maps.</summary>
 <param name="source">The source Map.</param>

 <returns>A tuple of each untupled Map.</returns>
</member>
<member name="M:FSharpPlus.Map.zip``3(Microsoft.FSharp.Collections.FSharpMap{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``2})">
 <summary>Tuples values of two Maps.</summary>
 <remarks>Keys that are not present on both Maps are dropped.</remarks>
 <param name="x">The first input Map.</param>
 <param name="y">The second input Map.</param>

 <returns>The tupled Map.</returns>
</member>
<member name="M:FSharpPlus.Map.chooseValues``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpMap{``2,``0})">
 <summary>Applies given function to each value of the given Map.</summary>
 <param name="mapping">The mapping function.</param>
 <param name="source">The input Map.</param>

 <returns>Returns Map with values x for each Map value where the function returns Some(x).</returns>
</member>
<member name="M:FSharpPlus.Map.mapValues3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Collections.FSharpMap{``4,``0},Microsoft.FSharp.Collections.FSharpMap{``4,``1},Microsoft.FSharp.Collections.FSharpMap{``4,``2})">
 <summary>Combines values from three maps using mapping function.</summary>
 <remarks>Keys that are not present on every Map are dropped.</remarks>
 <param name="mapping">The mapping function.</param>
 <param name="x">First input Map.</param>
 <param name="y">Second input Map.</param>
 <param name="z">Third input Map.</param>

 <returns>The mapped Map.</returns>
</member>
<member name="M:FSharpPlus.Map.mapValues2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{``3,``0},Microsoft.FSharp.Collections.FSharpMap{``3,``1})">
 <summary>Maps values of two Maps.</summary>
 <remarks>Keys that are not present on both Maps are dropped.</remarks>
 <param name="f">The mapping function.</param>
 <param name="x">The first input Map.</param>
 <param name="y">The second input Map.</param>

 <returns>The mapped Map.</returns>
</member>
<member name="M:FSharpPlus.Map.mapValues``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``2,``0})">
 <summary>Maps the values of the original Map.</summary>
 <remarks>
 The core `Map.map` function maps over values too, but it passes both
 key and value to the mapping function.
 </remarks>
 <param name="f">The mapping function - takes only the value, and returns the mapped value.</param>
 <param name="x">The input Map.</param>

 <returns>The mapped Map.</returns>
</member>
<member name="M:FSharpPlus.Map.values``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns the values of the given map.</summary>
 <param name="source">The input map.</param>

 <returns>A seq of the values in the map.</returns>
</member>
<member name="M:FSharpPlus.Map.keys``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns the keys of the given map.</summary>
 <param name="source">The input map.</param>

 <returns>A seq of the keys in the map.</returns>
</member>
<member name="T:FSharpPlus.Map">
<summary>
 Additional operations on Map&lt;&apos;Key, &apos;Value&gt;
</summary>
</member>
<member name="M:FSharpPlus.Dictionary.choosei``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},System.Collections.Generic.IDictionary{``0,``1})">
 <summary>Same as chooseValues but with access to the key.</summary>
 <param name="f">The mapping function, taking key and element as parameters.</param>
 <param name="x">The input dictionary.</param>

 <returns>Dictionary with values (k, x) for each dictionary value where the function returns Some(x).</returns>
</member>
<member name="M:FSharpPlus.Dictionary.intersect``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
<summary>
Returns the intersection of two maps, preferring values from the first in case of duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Dictionary.intersectWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.Dictionary{``1,``0},System.Collections.Generic.Dictionary{``1,``0})">
<summary>
 Returns the intersection of two Dicts, using the combiner function for duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Dictionary.union``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
<summary>
Returns the union of two maps, preferring values from the first in case of duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Dictionary.unionWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.Dictionary{``1,``0},System.Collections.Generic.Dictionary{``1,``0})">
<summary>
 Returns the union of two dictionaries, using the combiner function for duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Dictionary.unzip``3(System.Collections.Generic.Dictionary{``0,System.Tuple{``1,``2}})">
 <summary>Splits a dictionary with tuple pair values to two separate dictionaries.</summary>
 <param name="source">The source dictionary.</param>

 <returns>A tuple of each untupled dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dictionary.zip``3(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``2})">
 <summary>Tuples values of two dictionaries.</summary>
 <remarks>Keys that are not present on both dictionaries are dropped.</remarks>
 <param name="x">The first input dictionary.</param>
 <param name="y">The second input dictionary.</param>

 <returns>The tupled dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dictionary.chooseValues``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IDictionary{``2,``0})">
 <summary>Applies given function to each value of the given dictionary.</summary>
 <param name="f">The mapping function.</param>
 <param name="x">The input dictionary.</param>

 <returns>Returns dictionary with values x for each dictionary value where the function returns Some(x).</returns>
</member>
<member name="M:FSharpPlus.Dictionary.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},System.Collections.Generic.Dictionary{``4,``0},System.Collections.Generic.Dictionary{``4,``1},System.Collections.Generic.Dictionary{``4,``2})">
 <summary>Combines values from three Dictionaries using mapping function.</summary>
 <remarks>Keys that are not present on every Dictionary are dropped.</remarks>
 <param name="mapping">The mapping function.</param>
 <param name="x">First input Dictionary.</param>
 <param name="y">Second input Dictionary.</param>
 <param name="z">Third input Dictionary.</param>

 <returns>The mapped Dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dictionary.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.Dictionary{``3,``0},System.Collections.Generic.Dictionary{``3,``1})">
 <summary>Creates a Dictionary value from a pair of Dictionaries, using a function to combine them.</summary>
 <remarks>Keys that are not present on both dictionaries are dropped.</remarks>
 <param name="mapping">The mapping function.</param>
 <param name="x">The first input dictionary.</param>
 <param name="y">The second input dictionary.</param>

 <returns>The combined dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dictionary.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.Dictionary{``2,``0})">
 <summary>Maps the given function over each value in the dictionary.</summary>
 <param name="mapping">The mapping function.</param>
 <param name="x">The input dictionary.</param>

 <returns>The mapped dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dictionary.values``2(System.Collections.Generic.Dictionary{``0,``1})">
 <summary>Returns the values of the given dictionary.</summary>
 <param name="source">The input dictionary.</param>

 <returns>A seq of the values in the dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dictionary.keys``2(System.Collections.Generic.Dictionary{``0,``1})">
 <summary>Returns the keys of the given dictionary.</summary>
 <param name="source">The input dictionary.</param>

 <returns>A seq of the keys in the dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dictionary.containsKey``2(``0,System.Collections.Generic.Dictionary{``0,``1})">
 <summary>Does the dictionary contain the given key?</summary>
 <remarks>Note: this is a function wrapper for the Dictionary.ContainsKey method.</remarks>
 <param name="k">The key to find.</param>
 <param name="dct">The input dictionary.</param>

 <returns>A bool indicating if the key was found</returns>
</member>
<member name="M:FSharpPlus.Dictionary.tryGetValue``2(``0,System.Collections.Generic.Dictionary{``0,``1})">
 <summary>Tries to get the value of the given key.</summary>
 <remarks>Note: this is a function wrapper for the Dictionary.TryGetValue method,
 which also represents the result as an Option&lt;value&gt; instead of a bool
 and an out-value.
 </remarks>
 <param name="k">The key to find.</param>
 <param name="dct">The input dictionary.</param>

 <returns>An option wrapped value</returns>
</member>
<member name="M:FSharpPlus.Dictionary.toIReadOnlyDictionary``2(System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Converts a Dictionary to an IReadOnlyDictionary
</summary>
</member>
<member name="T:FSharpPlus.Dictionary">
<summary>
 Additional operations on Dictionary&lt;&apos;Key, &apos;Value&gt;
</summary>
</member>
<member name="M:FSharpPlus.Dict.choosei``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},System.Collections.Generic.IDictionary{``0,``1})">
 <summary>Choose with access to the key.</summary>
 <param name="f">The mapping function, taking key and element as parameters.</param>
 <param name="x">The input dictionary.</param>

 <returns>Dictionary with values (k, x) for each dictionary value where the function returns Some(x).</returns>
</member>
<member name="M:FSharpPlus.Dict.intersect``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
<summary>
Returns the intersection of two Dicts, preferring values from the first in case of duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Dict.intersectWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IDictionary{``1,``0},System.Collections.Generic.IDictionary{``1,``0})">
<summary>
 Returns the intersection of two Dicts, using the combiner function for duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Dict.union``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
<summary>
Returns the union of two maps, preferring values from the first in case of duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Dict.unionWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IDictionary{``1,``0},System.Collections.Generic.IDictionary{``1,``0})">
<summary>
 Returns the union of two dictionaries, using the combiner function for duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Dict.unzip``3(System.Collections.Generic.IDictionary{``0,System.Tuple{``1,``2}})">
 <summary>Splits a dictionary with tuple pair values to two separate dictionaries.</summary>
 <param name="source">The source dictionary.</param>

 <returns>A tuple of each untupled dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dict.zip``3(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``2})">
 <summary>Tuples values of two dictionaries.</summary>
 <remarks>Keys that are not present on both dictionaries are dropped.</remarks>
 <param name="x">The first input dictionary.</param>
 <param name="y">The second input dictionary.</param>

 <returns>The tupled dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dict.chooseValues``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IDictionary{``2,``0})">
 <summary>Applies given function to each value of the given dictionary.</summary>
 <param name="f">The mapping function.</param>
 <param name="x">The input dictionary.</param>

 <returns>Returns dictionary with values x for each dictionary value where the function returns Some(x).</returns>
</member>
<member name="M:FSharpPlus.Dict.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IDictionary{``3,``0},System.Collections.Generic.IDictionary{``3,``1})">
 <summary>Creates a Dictionary value from a pair of Dictionaries, using a function to combine them.</summary>
 <remarks>Keys that are not present on both dictionaries are dropped.</remarks>
 <param name="f">The mapping function.</param>
 <param name="x">The first input dictionary.</param>
 <param name="y">The second input dictionary.</param>

 <returns>The combined dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dict.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IDictionary{``2,``0})">
 <summary>Maps the given function over each value in the dictionary.</summary>
 <param name="f">The mapping function.</param>
 <param name="x">The input dictionary.</param>

 <returns>The mapped dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dict.values``2(System.Collections.Generic.IDictionary{``0,``1})">
 <summary>Returns the values of the given dictionary.</summary>
 <param name="source">The input dictionary.</param>

 <returns>A seq of the values in the dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dict.keys``2(System.Collections.Generic.IDictionary{``0,``1})">
 <summary>Returns the keys of the given dictionary.</summary>
 <param name="source">The input dictionary.</param>

 <returns>A seq of the keys in the dictionary.</returns>
</member>
<member name="M:FSharpPlus.Dict.containsKey``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
 <summary>Does the dictionary contain the given key?</summary>
 <remarks>Note: this is a function wrapper for the IDictionary.ContainsKey method</remarks>
 <param name="k">The key to find.</param>
 <param name="dct">The input dictionary.</param>

 <returns>A bool indicating if the key was found</returns>
</member>
<member name="M:FSharpPlus.Dict.tryGetValue``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
 <summary>Tries to get the value of the given key.</summary>
 <remarks>This is a function wrapper for the IDictionary.TryGetValue method,
 representing the result as an Option&lt;value&gt; instead of a bool plus an out-value.
 </remarks>
 <param name="k">The key whose value you wish to find.</param>
 <param name="dct">The input dictionary.</param>

 <returns>An option wrapped value</returns>
</member>
<member name="M:FSharpPlus.Dict.toIReadOnlyDictionary``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Converts an IDictionary to an IReadOnlyDictionary.
</summary>
</member>
<member name="T:FSharpPlus.Dict">
<summary>
 Additional operations on IDictionary&lt;&apos;Key, &apos;Value&gt;
</summary>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.intersect``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
<summary>
 Returns the intersection of two read-only dictionaries, preferring values from the first in case of duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.intersectWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IReadOnlyDictionary{``1,``0},System.Collections.Generic.IReadOnlyDictionary{``1,``0})">
<summary>
 Returns the intersection of two read-only dictionaries, using the combiner function for duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.union``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
<summary>
 Returns the union of two read-only dictionaries, preferring values from the first in case of duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.unionWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IReadOnlyDictionary{``1,``0},System.Collections.Generic.IReadOnlyDictionary{``1,``0})">
<summary>
 Returns the union of two read-only dictionaries, using the combiner function for duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.unzip``3(System.Collections.Generic.IReadOnlyDictionary{``0,System.Tuple{``1,``2}})">
 <summary>Splits a read-only dictionary with tuple pair values to two separate read-only dictionaries.</summary>
 <param name="source">The source IReadOnlyDictionary.</param>

 <returns>A tuple of each untupled IReadOnlyDictionary.</returns>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.zip``3(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``2})">
 <summary>Tuples values of two read-only dictionaries.</summary>
 <remarks>Keys that are not present on both read-only dictionaries are dropped.</remarks>
 <param name="x">The first input IReadOnlyDictionary.</param>
 <param name="y">The second input IReadOnlyDictionary.</param>

 <returns>The tupled IReadOnlyDictionary.</returns>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.chooseValues``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IReadOnlyDictionary{``2,``0})">
 <summary>Applies given function to each value of the given read-only dictionary.</summary>
 <param name="f">The mapping function.</param>
 <param name="x">The input IReadOnlyDictionary.</param>

 <returns>Returns IReadOnlyDictionary with values x for each dictionary value where the function returns Some(x).</returns>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IReadOnlyDictionary{``3,``0},System.Collections.Generic.IReadOnlyDictionary{``3,``1})">
 <summary>Creates a read-only dictionary value from a pair of read-only dictionaries,
 using a function to combine them.</summary>
 <remarks>Keys that are not present on both read-only dictionaries are dropped.</remarks>
 <param name="f">The mapping function.</param>
 <param name="x">The first input IReadOnlyDictionary.</param>
 <param name="y">The second input IReadOnlyDictionary.</param>

 <returns>The combined IReadOnlyDictionary.</returns>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``2,``0})">
 <summary>Maps the given function over each value in the read-only dictionary.</summary>
 <param name="f">The mapping function.</param>
 <param name="x">The input IReadOnlyDictionary.</param>

 <returns>The mapped IReadOnlyDictionary.</returns>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.values``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
 <summary>Returns the values of the given read-only dictionary.</summary>
 <param name="source">The input IReadOnlyDictionary.</param>

 <returns>A seq of the values in the read-only dictionary.</returns>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.keys``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
 <summary>Returns the keys of the given read-only dictionary.</summary>
 <param name="source">The input IReadOnlyDictionary.</param>

 <returns>A seq of the keys in the IReadOnlyDictionary.</returns>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.containsKey``2(``0,System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
 <summary>Does the read-only dictionary contain the given key?</summary>
 <remarks>Note: this is a function wrapper for the IReadOnlyDictionary.ContainsKey method.</remarks>
 <param name="k">The key to find.</param>
 <param name="dct">The input IReadOnlyDictionary.</param>

 <returns>A bool indicating if the key was found.</returns>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.tryGetValue``2(``0,System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
 <summary>Tries to get the value of the given key.</summary>
 <remarks>This is a function wrapper for the IReadOnlyDictionary.TryGetValue method,
 representing the result as an Option&lt;value&gt; instead of a bool plus an out-value.
 </remarks>
 <param name="k">The key whose value you wish to find.</param>
 <param name="dct">The input IReadOnlyDictionary.</param>

 <returns>An option wrapped value.</returns>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.remove``2(``0,System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
<summary>
 Removes the given key from the read-only dictionary.
</summary>
</member>
<member name="M:FSharpPlus.IReadOnlyDictionary.add``2(``0,``1,System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
<summary>
 Replaces or sets the item associated with a specified key with the specified value.
</summary>
</member>
<member name="T:FSharpPlus.IReadOnlyDictionary">
<summary>
 Additional operations on IReadOnlyDictionary&lt;&apos;Key, &apos;Value&gt;
</summary>
</member>
<member name="T:FSharpPlus.Enumerator.MapEnumerator`1">
<summary>
 An abstract enumerator, useful when mapping over enumerators.
 
 It maintains a mutable `curr` item, and a process MapEnumeratorState `state`.
 
 Implement DoMoveNext such that `curr` is set after calling, and return
 whether the enumerator actually moved next.
 [omit]
</summary>
</member>
<member name="T:FSharpPlus.Enumerator.MapEnumeratorState">
<summary>
 Defines the possible states of a MapEnumerator.
 [omit]
</summary>
</member>
<member name="T:FSharpPlus.Enumerator.ConcatEnumerator`1">
<summary>
 Enumerate all sources in sequence
 [omit]
</summary>
</member>
<member name="T:FSharpPlus.Enumerator.IFinallyEnumerator">
<summary>
 [omit]
</summary>
</member>
<member name="T:FSharpPlus.Enumerator.EmptyEnumerator`1">
<summary>
 An enumerator that is empty -- useful in combination with other enumerators
 [omit]
</summary>
</member>
<member name="M:FSharpPlus.Enumerator.zip3``3(System.Collections.Generic.IEnumerator{``0},System.Collections.Generic.IEnumerator{``1},System.Collections.Generic.IEnumerator{``2})">
 <summary>
 Zip three input Enumerators into a new Enumerator yielding triples.
 </summary>
 <param name="e1">The first input Enumerator.</param>
 <param name="e2">The second input Enumerator.</param>
 <param name="e3">The third input Enumerator.</param>
 <returns>An Enumerator that enumerates triples of three input Enumerators.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.zip``2(System.Collections.Generic.IEnumerator{``0},System.Collections.Generic.IEnumerator{``1})">
 <summary>
 Zip two input Enumerators into a new Enumerator yielding pairs.
 </summary>
 <param name="e1">The first input Enumerator.</param>
 <param name="e2">The second input Enumerator.</param>
 <returns>An Enumerator that enumerates pairs of two input Enumerators.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.upto``1(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>
 Enumerates from zero up to the given <c>lastOption</c>, yielding elements
 generated by the given function applied to the index.
 </summary>
 <remarks>
 The Current value for a valid index is "f i".

 Lazy&lt;_&gt; values are used as caches, to store either the result or an exception if thrown.
 
 These "Lazy&lt;_&gt;" caches are created only on the first call to current and forced immediately.
 The lazy creation of the cache nodes means enumerations that skip many Current values are not delayed by GC.
 For example, the full enumeration of Seq.initInfinite in the tests.
 </remarks>
 <param name="lastOption">The last index to stop at -- or <c>None</c> to run forever, well as far as Int32.MaxValue.</param>
 <param name="f">The function to apply to each index.</param>
 <returns>An enumerator that yields upto the lastOption.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
 <summary>
 Returns a new Enumerator yielding elements <c>x</c> generated by the given computation
 so long as it generates a <c>Some(x)</c> - and stops when it generates a <c>None</c>.
 The given initial <c>state</c> argument is passed to the element generator.
 </summary>
 <param name="generator">The function that takes the current state and returns an
 option tuple of the next element of the list and the next state value.</param>
 <param name="initialState">The intitial state value.</param>
 <returns>A new Enumerator yielding only elements that satsify the predicate.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerator{``0})">
 <summary>
 Returns a new Enumerator yielding only the elements of the input Enumerator for which the
 given predicate returns "true".
 </summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="e">The input Enumerator.</param>
 <returns>A new Enumerator yielding only elements that satsify the predicate.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerator{``0})">
 <summary>
 Applies the given function to each element in the input Enumerator.
 Returns an Enumerator comprised of the resuls <c>x</c> for each element
 where the function returns <c>Some(x)</c>.
 </summary>
 <param name="chooser">The function to apply to each triple of elements from the input Enumerators.</param>
 <param name="e">The input Enumerator.</param>
 <returns>A new Enumerator of values selected from the chooser function.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},System.Collections.Generic.IEnumerator{``0},System.Collections.Generic.IEnumerator{``1},System.Collections.Generic.IEnumerator{``2})">
 <summary>
 Maps over three Enumerators, where the mapping function is given the corresponding elements
 of the three Enumerators.
 </summary>
 <remarks>
 Stops enumerating when any of the input Enumerators are finished enumerating.
 </remarks>
 <param name="f">The function to apply to each triple of elements from the input Enumerators.</param>
 <param name="e1">The first input Enumerator.</param>
 <param name="e2">The second input Enumerator.</param>
 <param name="e3">The third input Enumerator.</param>
 <returns>A new Enumerator of mapped elements.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.IEnumerator{``0},System.Collections.Generic.IEnumerator{``1})">
 <summary>
 Maps over two Enumerators, where the mapping function is given the index and corresponding elements
 of the two input Enumerators pairwise.
 </summary>
 <remarks>
 Stops enumerating when either of the input Enumerators are finished enumerating.
 </remarks>
 <param name="f">The function to apply to the index and each pair of elements from the input Enumerators.</param>
 <param name="e1">The first input Enumerator.</param>
 <param name="e2">The second input Enumerator.</param>
 <returns>A new Enumerator of mapped elements.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IEnumerator{``0},System.Collections.Generic.IEnumerator{``1})">
 <summary>
 Maps over two Enumerators, with the mapping function is given the corresponding elements
 of the two Enumerators pairwise.
 </summary>
 <remarks>
 Stops enumerating when either of the input Enumerators are finished enumerating.
 </remarks>
 <param name="f">The function to apply to each pair of elements from the input Enumerators.</param>
 <param name="e1">The first input Enumerator.</param>
 <param name="e2">The second input Enumerator.</param>
 <returns>A new Enumerator of mapped elements.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.IEnumerator{``0})">
 <summary>
 Maps over an Enumerator, with the mapping function also given the index.
 </summary>
 <param name="f">The function to apply, which is given both the index and the element.</param>
 <param name="e">The input Enumerator.</param>
 <returns>A new Enumerator of mapped elements.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerator{``0})">
 <summary>
 Maps over an enumerator.
 </summary>
 <param name="f">The function to apply.</param>
 <param name="e">The input Enumerator.</param>
 <returns>A new Enumerator of mapped elements.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.nth``1(System.Int32,System.Collections.Generic.IEnumerator{``0})">
 <summary>
 Retuns the nth element in the Enumerator.
 </summary>
 <remarks>
 This is called <c>item</c> in some other parts of core.
 </remarks>
 <param name="index">The index to retrieve.</param>
 <param name="e">The input Enumerator.</param>
 <returns>The value at the given index or an exception is thrown if not found.</returns>
 <exception cref="System.ArgumentException">
 Thrown if the index is negative or the Enumerator does not contain enough elements.
 </exception>
</member>
<member name="M:FSharpPlus.Enumerator.tryItem``1(System.Int32,System.Collections.Generic.IEnumerator{``0})">
 <summary>
 Tries to find the nth element in the Enumerator.
 Returns None if index is negative or the Enumerator does not contain enough elements. 
 </summary>
 <param name="index">The index to retrieve.</param>
 <param name="e">The input Enumerator.</param>
 <returns>The value at the given index or <c>None</c> if not found.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.concat``1(System.Collections.Generic.IEnumerator{System.Collections.Generic.IEnumerator{``0}})">
 <summary>
 Enumerates the elements of each of the Enumerators in order.
 </summary>
 <param name="sources">The source Enumerator of Enumerators.</param>
 <returns>A concatenated enumeration of the given Enumerator sources.</returns>
</member>
<member name="M:FSharpPlus.Enumerator.singleton``1(``0)">
<summary>
 Constructs an Enumerator that yields the single value given.
</summary>
</member>
<member name="M:FSharpPlus.Enumerator.Empty``1">
<summary>
 Constructs an EmptyEnumerator of type &apos;T.
</summary>
</member>
<member name="M:FSharpPlus.Enumerator.dispose(System.IDisposable)">
<summary>
 [omit]
</summary>
</member>
<member name="M:FSharpPlus.Enumerator.check(System.Boolean)">
<summary>
 [omit]
</summary>
</member>
<member name="M:FSharpPlus.Enumerator.alreadyFinished``1">
<summary>
 [omit]
</summary>
</member>
<member name="M:FSharpPlus.Enumerator.notStarted``1">
<summary>
 [omit]
</summary>
</member>
<member name="M:FSharpPlus.Enumerator.noReset``1">
<summary>
 [omit]
</summary>
</member>
<member name="M:FSharpPlus.Enumerator.invalidArgFmt``1(System.String,System.String,System.Object[])">
<summary>
 [omit]
</summary>
</member>
<member name="T:FSharpPlus.Enumerator">
<summary>
 Additional operations on IEnumerator
</summary>
</member>
<member name="M:FSharpPlus.Task.raise``1(System.Exception)">
<summary>
 Raises an exception in the Task
</summary>
</member>
<member name="M:FSharpPlus.Task.using``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}})">
<summary>
 Used to de-sugar use .. blocks in Computation Expressions.
</summary>
</member>
<member name="M:FSharpPlus.Task.tryFinally``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task{``0}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Used to de-sugar try .. finally .. blocks in Computation Expressions.
</summary>
</member>
<member name="M:FSharpPlus.Task.tryWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task{``0}},Microsoft.FSharp.Core.FSharpFunc{System.Exception,System.Threading.Tasks.Task{``0}})">
<summary>
 Used to de-sugar try .. with .. blocks in Computation Expressions.
</summary>
</member>
<member name="M:FSharpPlus.Task.ignore(System.Threading.Tasks.Task)">
 <summary>Creates a task that ignores the result of the source task.</summary>
 <remarks>It can be used to convert non-generic Task to unit Task.</remarks>
</member>
<member name="M:FSharpPlus.Task.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}},System.Threading.Tasks.Task{``0})">
 <summary>Creates a task workflow from 'source' workflow, mapping and flattening its result with 'f'.</summary>
</member>
<member name="M:FSharpPlus.Task.join``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})">
<summary>
 Flattens two nested tasks into one.
</summary>
</member>
<member name="M:FSharpPlus.Task.zip``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
 <summary>Creates a task workflow from two workflows 'x' and 'y', tupling its results.</summary>
</member>
<member name="M:FSharpPlus.Task.apply``2(System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Threading.Tasks.Task{``0})">
 <summary>Creates a task workflow that is the result of applying the resulting function of a task workflow
 to the resulting value of another task workflow</summary>
 <param name="f">Task workflow returning a function</param>
 <param name="x">Task workflow returning a value</param>
</member>
<member name="M:FSharpPlus.Task.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Threading.Tasks.Task{``2})">
 <summary>Creates a task workflow from three workflows 'x', 'y' and z, mapping its results with 'f'.</summary>
 <remarks>Workflows are run in sequence.</remarks>
 <param name="f">The mapping function.</param>
 <param name="x">First task workflow.</param>
 <param name="y">Second task workflow.</param>
 <param name="z">Third task workflow.</param>
</member>
<member name="M:FSharpPlus.Task.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
 <summary>Creates a task workflow from two workflows 'x' and 'y', mapping its results with 'f'.</summary>
 <remarks>Workflows are run in sequence.</remarks>
 <param name="f">The mapping function.</param>
 <param name="x">First task workflow.</param>
 <param name="y">Second task workflow.</param>
</member>
<member name="M:FSharpPlus.Task.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Threading.Tasks.Task{``0})">
 <summary>Creates a task workflow from 'source' another, mapping its result with 'f'.</summary>
</member>
<member name="T:FSharpPlus.Task">
<summary>
 Additional operations on Task&lt;&apos;T&gt;
</summary>
</member>
<member name="M:FSharpPlus.Async.raise``1(System.Exception)">
<summary>
 Raises an exception in the async workflow
</summary>
</member>
<member name="M:FSharpPlus.Async.apply``2(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Creates an async workflow that is the result of applying the resulting function of
 an async workflow to the resulting value of another async workflow.</summary>
 <param name="f">Async workflow returning a function.</param>
 <param name="x">Async workflow returning a value.</param>
</member>
<member name="M:FSharpPlus.Async.join``1(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Flatten two nested asyncs into one.
</summary>
</member>
<member name="M:FSharpPlus.Async.zip``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
 <summary>Creates an async workflow from two workflows 'x' and 'y', tupling its results.</summary>
</member>
<member name="M:FSharpPlus.Async.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1},Microsoft.FSharp.Control.FSharpAsync{``2})">
 <summary>Creates an async workflow from three workflows 'x', 'y' and 'z', mapping its results with 'f'.</summary>
 <remarks>Workflows are run in sequence.</remarks>
 <param name="f">The mapping function.</param>
 <param name="x">First async workflow.</param>
 <param name="y">Second async workflow.</param>
 <param name="z">third async workflow.</param>
</member>
<member name="M:FSharpPlus.Async.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
 <summary>Creates an async workflow from two workflows 'x' and 'y', mapping its results with 'f'.</summary>
 <remarks>Workflows are run in sequence.</remarks>
 <param name="f">The mapping function.</param>
 <param name="x">First async workflow.</param>
 <param name="y">Second async workflow.</param>
</member>
<member name="M:FSharpPlus.Async.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Creates an async workflow from another workflow 'x', mapping its result with 'f'.</summary>
</member>
<member name="T:FSharpPlus.Async">
<summary>
 Additional operations on Async
</summary>
</member>
<member name="M:FSharpPlus.Extensions.Option`1.Sequence.Static``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Returns None if it contains a None element, otherwise a list of all elements
</summary>
</member>
<member name="M:FSharpPlus.Extensions.Async`1.Bisequence.Static``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Control.FSharpAsync{``1},Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Creates an async Choice from a Choice where both cases are async.
</summary>
</member>
<member name="M:FSharpPlus.Extensions.Async`1.Bisequence.Static``3(Microsoft.FSharp.Core.FSharpResult{Microsoft.FSharp.Control.FSharpAsync{``1},Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Creates an async Result from a Result where both cases are async.
</summary>
</member>
<member name="M:FSharpPlus.Extensions.Async`1.Sequence.Static``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Control.FSharpAsync{``1},``2})">
<summary>
 Creates an async Choice from a Choice where the Choice1Of2 case is async.
</summary>
</member>
<member name="M:FSharpPlus.Extensions.Async`1.Sequence.Static``3(Microsoft.FSharp.Core.FSharpResult{Microsoft.FSharp.Control.FSharpAsync{``1},``2})">
<summary>
 Creates an async Result from a Result where the Ok case is async.
</summary>
</member>
<member name="M:FSharpPlus.Extensions.Async`1.Sequence.Static``2(Microsoft.FSharp.Control.FSharpAsync{``1}[])">
<summary>
 Combine all asyncs in one, chaining them in sequence order.
</summary>
</member>
<member name="M:FSharpPlus.Extensions.Async`1.Sequence.Static``2(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Combine all asyncs in one, chaining them in sequence order.
</summary>
</member>
<member name="M:FSharpPlus.Extensions.Async`1.Sequence.Static``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Combine all asyncs in one, chaining them in sequence order.
</summary>
</member>
<member name="T:FSharpPlus.Extensions">
<summary>
 Module containing F#+ Extension Methods on existing types
</summary>
</member>
<member name="T:FSharpPlus.Tuple3">
<summary>
 Additional operations on Tuple (,,)
</summary>
</member>
<member name="T:FSharpPlus.Tuple2">
<summary>
 Additional operations on Tuple (,)
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToUInt64(System.Byte[],System.Int32,System.Boolean)">
<summary>
 Converts an array of bytes into an unsigned long.

</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToUInt32(System.Byte[],System.Int32,System.Boolean)">
<summary>
 Converts an array of bytes into an uint.

</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToUInt16(System.Byte[],System.Int32,System.Boolean)">
<summary>
 Converts an array of bytes into an ushort.

</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToString(System.Byte[],System.Int32)">
<summary>
 Converts an array of bytes into a String.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToString(System.Byte[])">
<summary>
 Converts an array of bytes into a String.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToString(System.Byte[],System.Int32,System.Int32)">
<summary>
 Converts an array of bytes into a String.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToSingle(System.Byte[],System.Int32,System.Boolean)">
<summary>
 Converts an array of bytes into a float.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToInt64(System.Byte[],System.Int32,System.Boolean)">
<summary>
 Converts an array of bytes into a long.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToInt32(System.Byte[],System.Int32,System.Boolean)">
<summary>
 Converts an array of bytes into an int.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToInt16(System.Byte[],System.Int32,System.Boolean)">
<summary>
 Converts an array of bytes into a short.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToDouble(System.Byte[],System.Int32,System.Boolean)">
<summary>
 Converts an array of bytes into a double.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.ToChar(System.Byte[],System.Int32,System.Boolean)">
<summary>
 Converts an array of bytes into a char.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.GetBytes(System.Double,System.Boolean)">
<summary>
 Converts a double into an array of bytes with length
 eight.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.GetBytes(System.Single,System.Boolean)">
<summary>
 Converts a float into an array of bytes with length
 four.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.GetBytes(System.UInt64,System.Boolean)">
<summary>
 Converts an unsigned long into an array of bytes with
 length eight.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.GetBytes(System.UInt32,System.Boolean)">
<summary>
 Converts an uint into an array of bytes with
 length four.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.GetBytes(System.UInt16,System.Boolean)">
<summary>
 Converts an ushort into an array of bytes with
 length two.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.GetBytes(System.Int64,System.Boolean)">
<summary>
 Converts a long into an array of bytes with length
 eight.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.GetBytes(System.Int32,System.Boolean)">
<summary>
 Converts an int into an array of bytes with length
 four.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.GetBytes(System.Int16,System.Boolean)">
<summary>
 Converts a short into an array of bytes with length
 two.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.GetBytes(System.Char,System.Boolean)">
<summary>
 Converts a char into an array of bytes with length two.
</summary>
</member>
<member name="M:FSharpPlus.Internals.BitConverter.GetBytes(System.Boolean)">
<summary>
 Converts a byte into an array of bytes with length one.
</summary>
</member>
<member name="M:FSharpPlus.Internals.Constraints.whenNestedTuple``9(``0)">
<summary>
 Constrain &apos;t to be a nested tuple of &lt;&apos;t1,&apos;t2,&apos;t3,&apos;t4,&apos;t5,&apos;t6,&apos;t7,&apos;tr&gt;
</summary>
</member>
<member name="M:FSharpPlus.Operators.dispose(System.IDisposable)">
<summary>
 Safely dispose a resource (includes null-checking).
</summary>
</member>
<member name="M:FSharpPlus.Operators.|Parsed|_|``1(System.String)">
 <summary>
 An active recognizer for a generic value parser.
 </summary>
 <category index="23">Additional Functions</category>
</member>
<member name="M:FSharpPlus.Operators.|Parse|_|``1(System.String)">
 <category index="23">Additional Functions</category>
</member>
<member name="M:FSharpPlus.Operators.implicit``2(``0)">
<summary>
 Converts using the implicit operator. 
</summary>
</member>
<member name="M:FSharpPlus.Operators.sum``2(``0)">
<summary>
 Folds the sum of all monoid elements in the Foldable.
</summary>
</member>
<member name="M:FSharpPlus.Operators.mfilter``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
<summary>
 Generic filter operation for MonadZero. It returns all values satisfying the predicate, if the predicate returns false will use the empty value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.choice``2(``0)">
<summary>
 Reduces using alternative operator `&lt;|&gt;`.
</summary>
</member>
<member name="M:FSharpPlus.Operators.abs'``1(``0)">
 <summary> Gets the absolute value of the given number.
           Works also for unsigned types. 
 <para/>   Rule: signum x * abs x = x </summary>
 <param name="value">The input value.</param>
 <returns>The absolute value of the input.</returns>
</member>
<member name="M:FSharpPlus.Operators.abs``1(``0)">
 <summary> Gets the absolute value of the given number.
 <para/>   Rule: signum x * abs x = x </summary>
 <param name="value">The input value.</param>
 <returns>The absolute value of the input.</returns>
</member>
<member name="M:FSharpPlus.Operators.signum'``1(``0)">
 <summary>Sign of the given number
           Works also for unsigned types. 
 <para/>   Rule: signum x * abs x = x </summary>
 <param name="value">The input value.</param>
 <returns>-1, 0, or 1 depending on the sign of the input.</returns>
</member>
<member name="M:FSharpPlus.Operators.signum``1(``0)">
 <summary>Sign of the given number
 <para/>   Rule: signum x * abs x = x </summary>
 <param name="value">The input value.</param>
 <returns>-1, 0, or 1 depending on the sign of the input.</returns>
</member>
<member name="M:FSharpPlus.Operators.sqrtRem``1(``0)">
<summary>
 Square root of an integral number.
</summary>
</member>
<member name="M:FSharpPlus.Operators.isqrt``1(``0)">
<summary>
 Square root of an integral number.
</summary>
</member>
<member name="M:FSharpPlus.Operators.trySqrt``1(``0)">
<summary>
 Square root of a number of any type. Returns None if there is no square root.
</summary>
</member>
<member name="M:FSharpPlus.Operators.sqrt``1(``0)">
<summary>
 Square root of a number of any type. Throws an exception if there is no square root.
</summary>
</member>
<member name="M:FSharpPlus.Operators.tryDiv``1(``0,``0)">
<summary>
 Division between two numbers. Returns None if the numbers are not divisible.
</summary>
</member>
<member name="M:FSharpPlus.Operators.div``1(``0,``0)">
<summary>
 Division between two numbers. If the numbers are not divisible throws an error.
</summary>
</member>
<member name="M:FSharpPlus.Operators.trySubtract``1(``0,``0)">
<summary>
 Subtraction between two numbers. Returns None if the result is negative on unsigned types.
</summary>
</member>
<member name="M:FSharpPlus.Operators.subtract``1(``0,``0)">
<summary>
 Subtraction between two numbers. Throws an error if the result is negative on unsigned types.
</summary>
</member>
<member name="M:FSharpPlus.Operators.tryNegate'``1(``0)">
<summary>
 Additive inverse of the number.
 Works also for unsigned types (Returns none if there is no inverse).
</summary>
</member>
<member name="M:FSharpPlus.Operators.negate'``1(``0)">
<summary>
 Additive inverse of the number.
 Works also for unsigned types (Throws an exception if there is no inverse).
</summary>
</member>
<member name="M:FSharpPlus.Operators.negate``1(``0)">
<summary>
 Additive inverse of the number.
</summary>
</member>
<member name="M:FSharpPlus.Operators.pi``1">
<summary>
 The pi number.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getPi``1">
<summary>
 Gets the pi number.
</summary>
</member>
<member name="M:FSharpPlus.Operators.toBigInt``1(``0)">
<summary>
 Converts to BigInteger.
</summary>
</member>
<member name="M:FSharpPlus.Operators.fromBigInt``1(System.Numerics.BigInteger)">
 <summary>Converts from BigInteger to the inferred destination type.</summary>
</member>
<member name="M:FSharpPlus.Operators.maxValue``1">
<summary>
 The largest possible value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getMaxValue``1">
<summary>
 Gets the largest possible value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.minValue``1">
<summary>
 The smallest possible value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getMinValue``1">
<summary>
 Gets the smallest possible value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.divRem``1(``0,``0)">
<summary>
 Divides one number by another, returns a tuple with the result and the remainder.
</summary>
</member>
<member name="M:FSharpPlus.Operators.one``1">
<summary>
 A value that represents the 1 element.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getOne``1">
<summary>
 Gets a value that represents the number 1 (one).
</summary>
</member>
<member name="M:FSharpPlus.Operators.tryParse``1(System.String)">
<summary>
 Converts to a value from its string representation. Returns None if the convertion doesn&apos;t succeed.
</summary>
</member>
<member name="M:FSharpPlus.Operators.parse``1(System.String)">
<summary>
 Converts to a value from its string representation.
</summary>
</member>
<member name="M:FSharpPlus.Operators.toBytesBE``1(``0)">
<summary>
 Convert to a byte array value, assuming big endian
</summary>
</member>
<member name="M:FSharpPlus.Operators.toBytes``1(``0)">
<summary>
 Convert to a byte array value, assuming little endian
</summary>
</member>
<member name="M:FSharpPlus.Operators.ofBytesBE``1(System.Byte[])">
<summary>
 Convert from a byte array value, assuming big-endian
</summary>
</member>
<member name="M:FSharpPlus.Operators.ofBytes``1(System.Byte[])">
<summary>
 Convert from a byte array value, assuming little-endian
</summary>
</member>
<member name="M:FSharpPlus.Operators.ofBytesWithOptions``1(System.Boolean,System.Int32,System.Byte[])">
<summary>
 Convert from a byte array value, given options of little-endian, and startIndex
</summary>
</member>
<member name="M:FSharpPlus.Operators.explicit``2(``0)">
<summary>
 Converts using the explicit operator.
</summary>
</member>
<member name="M:FSharpPlus.Operators.mapItem5``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps the fifth value of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.mapItem4``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps the fourth value of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.mapItem3``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps the third value of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.mapItem2``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps the second value of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.mapItem1``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps the first value of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item5``2(``0)">
<summary>
 Gets the value of the fifth component of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item4``2(``0)">
<summary>
 Gets the value of the fourth component of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item3``2(``0)">
<summary>
 Gets the value of the third component of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item2``2(``0)">
<summary>
 Gets the value of the second component of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item1``2(``0)">
<summary>
 Gets the value of the first component of a tuple.
</summary>
</member>
<member name="M:FSharpPlus.Operators.split``2(``0,``1)">
<summary>
 Splits a given ordered collection at each of the given sub-ordered collections

 &lt;example&gt;
 &lt;code&gt;
 &gt; &quot;asdf&quot; |&gt; split [&quot;s&quot;];;
 val it : string list = [&quot;a&quot;; &quot;df&quot;]

 &gt; [1;2;3;4;5;6;7] |&gt; split [ [2;3]; [5] ];;
 val it : int list list = [[1]; [4]; [6; 7]]
 &lt;/code&gt;
 &lt;/example&gt;
</summary>
</member>
<member name="M:FSharpPlus.Operators.sortByDescending``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary>Yields a collection ordered descending by keys.</summary>
 
 <remarks>This function makes no assumption on the ordering of the original collection.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="projection">A function to transform items of the input collection into comparable keys.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
</member>
<member name="M:FSharpPlus.Operators.sortBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary>Applies a key-generating function to each element of a collection and returns a collection ordered
 by keys. The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.</summary> 
 
 <remarks>This function makes no assumption on the ordering of the original collection.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="projection">A function to transform items of the input collection into comparable keys.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
</member>
<member name="M:FSharpPlus.Operators.sort``1(``0)">
 <summary>Returns a collection ordered by keys.</summary>
 
 <remarks>This function makes no assumption on the ordering of the original collection.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
</member>
<member name="M:FSharpPlus.Operators.scan``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2)">
 <summary>Like fold, but computes on-demand and returns the collection of intermediary and final results.</summary>

 <param name="folder">A function that updates the state with each element from the collection.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input collection.</param>

 <returns>The resulting collection of computed states.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
</member>
<member name="M:FSharpPlus.Operators.rev``1(``0)">
 <summary>Returns a new collection with the elements in reverse order.</summary>
 <param name="source">The input collection.</param>
 <returns>The reversed collection.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
</member>
<member name="M:FSharpPlus.Operators.replace``1(``0,``0,``0)">
 <summary>Replaces part of the collection with a new part</summary>

 <param name="oldValue">A collection that if part of the source collection
 should be replaced with newValue.</param>
 <param name="newValue">The collection to replace oldValue with.</param>
 <param name="source">The input collection.</param>

 <returns>The resulting collection with oldValue replaced with newValue.</returns>
</member>
<member name="M:FSharpPlus.Operators.intersperse``2(``0,``1)">
<summary>
 Inserts a separator between each element.
</summary>
</member>
<member name="M:FSharpPlus.Operators.distinctBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary>Returns a collection that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the collection then the later occurrences are discarded.</summary>

 <param name="projection">A function transforming the collection items into comparable keys.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
</member>
<member name="M:FSharpPlus.Operators.distinct``1(``0)">
 <summary>Returns a collection that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the collection then the later occurrences are discarded.</summary>

 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
</member>
<member name="M:FSharpPlus.Operators.choose``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``2)">
 <summary>
 Generic 'choose' for any collection.
 
 A combination of map and filter, `choose` enables you to transform
 and select elements at the same time.
 </summary>

 <param name="chooser">
 A function that is applied to each element in the
 collection and returns an option value. When the result is a Some then
 the unwrapped value is included in the result collection, otherwise
 it is discarded.
 </param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.InvalidOperationException">Thrown when the input collection is an Id.</exception>
</member>
<member name="M:FSharpPlus.Operators.skipWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
 <summary>Bypasses elements in a collection while the given predicate returns true, and then returns
 the remaining elements of the collection.</summary>

 <param name="predicate">A function that evaluates to false when no more items should be skipped.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
</member>
<member name="M:FSharpPlus.Operators.takeWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
 <summary>Returns a collection that contains all elements of the original collection while the
 given predicate returns true, and then returns no further elements.</summary>

 <param name="predicate">A function that evaluates to false when no more items should be returned.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
</member>
<member name="M:FSharpPlus.Operators.chunkBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary>Applies a key-generating function to each element of a collection and yields a collection of 
 keys tupled with values. Each key contains a collection of all adjacent elements that match 
 to this key, therefore keys are not unique but they can't be adjacent
 as each time the key changes, a new group is yield.</summary>
 
 <remarks>The ordering of the original collection is respected.</remarks>

 <param name="projection">A function that transforms an element of the collection into a comparable key.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>
</member>
<member name="M:FSharpPlus.Operators.groupBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary>Applies a key-generating function to each element of a collection and yields a collection of 
 unique keys. Each unique key contains a collection of all elements that match 
 to this key.</summary>
 
 <remarks>This function returns a collection that digests the whole initial collection as soon as 
 that collection is iterated. As a result this function should not be used with 
 large or infinite collections. The function makes no assumption on the ordering of the original 
 collection.</remarks>

 <param name="projection">A function that transforms an element of the collection into a comparable key.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>
</member>
<member name="M:FSharpPlus.Operators.limit``1(System.Int32,``0)">
 <summary>Returns a collection with at most N elements.</summary>

 <param name="count">The maximum number of items to return.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharpPlus.Operators.drop``1(System.Int32,``0)">
 <summary>Returns a collection that drops N elements of the original collection and then yields the
 remaining elements of the collection.</summary>
 <remarks>When count exceeds the number of elements in the collection it
 returns an empty collection instead of throwing an exception.</remarks>
 <param name="count">The number of items to drop.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>
</member>
<member name="M:FSharpPlus.Operators.take``1(System.Int32,``0)">
 <summary>Gets the first N elements of the collection.</summary>
 <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the collection. <c>limit</c>
 returns as many items as the collection contains instead of throwing an exception.</remarks>

 <param name="count">The number of items to take.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input collection is empty.</exception>
 <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the collection.</exception>
</member>
<member name="M:FSharpPlus.Operators.skip``1(System.Int32,``0)">
 <summary>Returns a collection that skips N elements of the original collection and then yields the
 remaining elements of the collection.</summary>
 <remarks>Throws <c>InvalidOperationException</c>
 when count exceeds the number of elements in the collection. <c>drop</c>
 returns an empty collection instead of throwing an exception.</remarks>
 <param name="count">The number of items to skip.</param>
 <param name="source">The input collection.</param>

 <returns>The result collection.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
 <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the collection.</exception>
</member>
<member name="M:FSharpPlus.Operators.filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true"</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="source">The input collection.</param>
 <returns>A collection containing only the elements that satisfy the predicate.</returns>
</member>
<member name="M:FSharpPlus.Operators.ofSeq``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Converts to a Collection from a seq.
</summary>
</member>
<member name="M:FSharpPlus.Operators.ofList``2(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Converts to a Collection from a list.
</summary>
</member>
<member name="M:FSharpPlus.Operators.bindError``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary>
 Executes a handler when the value contained in the Error monad represents an error.
 </summary>
</member>
<member name="M:FSharpPlus.Operators.catch``3(``0,Microsoft.FSharp.Core.FSharpFunc{``2,``1})">
 <summary> Executes a handler when the value contained in the Error monad represents an error. </summary>
</member>
<member name="M:FSharpPlus.Operators.throw``2(``0)">
<summary>
 Throws an error value inside the Error monad.
</summary>
</member>
<member name="M:FSharpPlus.Operators.pass``2(``0)">
<summary>
 Executes the action &lt;paramref name=&quot;m&quot;/&gt;, which returns a value and a function, and returns the value, applying the function to the output.
</summary>
</member>
<member name="M:FSharpPlus.Operators.listen``2(``0)">
 <summary> Executes the action <paramref name="m"/> and adds its output to the value of the computation. </summary>
 <param name="m">The action to be executed.</param>
</member>
<member name="M:FSharpPlus.Operators.tell``2(``0)">
<summary>
 Embeds a simple writer action.
</summary>
</member>
<member name="M:FSharpPlus.Operators.local``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary> Executes a computation in a modified environment. </summary>
 <param name="f"> The function to modify the environment.    </param>
 <param name="m"> Reader to run in the modified environment. </param>
</member>
<member name="M:FSharpPlus.Operators.ask``1">
<summary>
 The environment from the monad.
</summary>
</member>
<member name="M:FSharpPlus.Operators.modify``3(Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 Modifies the state inside the monad by applying a function.
</summary>
</member>
<member name="M:FSharpPlus.Operators.put``2(``0)">
<summary>
 Replaces the state inside the monad.
</summary>
</member>
<member name="M:FSharpPlus.Operators.gets``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Gets a value which depends on the current state.
</summary>
</member>
<member name="M:FSharpPlus.Operators.get``1">
<summary>
 The state from the internals of the monad.
</summary>
</member>
<member name="M:FSharpPlus.Operators.callCC``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2})">
<summary>
 Calls a function with the current continuation as its argument (call-with-current-continuation).
</summary>
</member>
<member name="M:FSharpPlus.Operators.liftAsync``2(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 A specialized lift for Async&lt;&apos;T&gt; which is able to bring an Async value from any depth of monad-layers.
</summary>
</member>
<member name="M:FSharpPlus.Operators.lift``2(``0)">
<summary>
 Lifts a computation from the inner monad to the constructed monad.
</summary>
</member>
<member name="M:FSharpPlus.Operators.duplicate``2(``0)">
<summary>
 Duplicates a comonadic context.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_EqualsGreaterGreater``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary> Extends a local context-dependent computation to a global computation.
 Same as <c>extend</c> but with flipped arguments. </summary>
</member>
<member name="M:FSharpPlus.Operators.extend``3(Microsoft.FSharp.Core.FSharpFunc{``0,``2},``0)">
 <summary> Extends a local context-dependent computation to a global computation. </summary>
</member>
<member name="M:FSharpPlus.Operators.extract``2(``0)">
<summary>
 Extracts a value from a comonadic context.
</summary>
</member>
<member name="M:FSharpPlus.Operators.tryFindSliceIndex``2(``0,``0)">
 <summary>
 Gets the index of the first occurrence of the specified slice in the source.
 Returns <c>None</c> if not found.
 </summary>
 <param name="slice">The slice to be searched.</param>
 <param name="source">The input collection.</param>
 <returns>
 The index of the slice or <c>None</c>.
 </returns>
</member>
<member name="M:FSharpPlus.Operators.findSliceIndex``2(``0,``0)">
 <summary>
 Gets the index of the first occurrence of the specified slice in the source.
 </summary>
 <param name="slice">The slice to be searched.</param>
 <param name="source">The input collection.</param>
 <exception cref="System.ArgumentException">
 Thrown when the slice was not found in the source.
 </exception>
 <returns>
 The index of the slice.
 </returns>
</member>
<member name="M:FSharpPlus.Operators.tryFindIndex``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
 <summary>
 Gets the index of the first element in the source
 that satisfies the given predicate.
 Returns <c>None</c> if not found.
 </summary>
 <param name="predicate">
 The function to test the input elements.
 </param>
 <param name="source">The input collection.</param>
 <returns> 
 The index of the first element that satisfies the predicate, or <c>None</c>.
 </returns>
</member>
<member name="M:FSharpPlus.Operators.findIndex``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
 <summary>
 Gets the index of the first element in the source
 that satisfies the given predicate.
 </summary>
 <param name="predicate">
 The function to test the input elements.
 </param>
 <param name="source">The input collection.</param>
 <returns> 
 The index of the first element that satisfies the predicate.
 </returns>
 <exception cref="System.ArgumentException">
 Thrown if the predicate evaluates to false for all the elements of the source.
 </exception>
</member>
<member name="M:FSharpPlus.Operators.traversei``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3)">
<summary>
 Traverses an indexed container. Behaves exactly like a regular traverse except that the traversing function also has access to the key associated with a value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.foldi``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,``3)">
<summary>
 Left-associative fold of an indexed container with access to the index i.
</summary>
</member>
<member name="M:FSharpPlus.Operators.iteri``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},``2)">
<summary>
 Maps an action with access to an index.
</summary>
</member>
<member name="M:FSharpPlus.Operators.choosei``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},``3)">
 <summary>
 Choose with access to the index.
 </summary>
 <param name="mapping">The mapping function, taking index and element as parameters.</param>
 <param name="source">The input collection.</param>
 <category index="16">Indexable</category>
</member>
<member name="M:FSharpPlus.Operators.mapi``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3)">
<summary>
 Maps with access to the index.
</summary>
</member>
<member name="M:FSharpPlus.Operators.tryItem``3(``0,``1)">
<summary>
 Tries to get an item from the given index.
</summary>
</member>
<member name="M:FSharpPlus.Operators.item``3(``0,``1)">
<summary>
 Gets an item from the given index.
</summary>
</member>
<member name="M:FSharpPlus.Operators.bisum``2(``0)">
<summary>
 Combines the elements of a structure using a monoid.
</summary>
</member>
<member name="M:FSharpPlus.Operators.bifoldBack``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``3,``1)">
<summary>
 Combines the elements of a structure in a left associative manner.
</summary>
</member>
<member name="M:FSharpPlus.Operators.bifold``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``0}},``0,``3)">
<summary>
 Combines the elements of a structure in a right associative manner.
</summary>
</member>
<member name="M:FSharpPlus.Operators.bifoldMap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},``3)">
<summary>
 Combines the elements of a structure, given ways of mapping them to a common monoid.
</summary>
</member>
<member name="M:FSharpPlus.Operators.sequence``2(``0)">
<summary>
 Evaluate each action in the structure from left to right, and collect the results.
</summary>
</member>
<member name="M:FSharpPlus.Operators.traverse``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.
</summary>
</member>
<member name="M:FSharpPlus.Operators.reduce``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``1)">
 <summary>Applies a function to each element of the reducible, threading an accumulator argument
 through the computation. Apply the function to the first two elements of the reducible.
 Then feed this result into the function along with the third element and so on. 
 Return the final result. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f i0 i1) i2 ...) iN</c>.</summary>
 <param name="reduction">The function to reduce two reducible elements to a single element.</param>
 <param name="source">The input reducible.</param>
 <returns>The final reduced value.</returns>
</member>
<member name="M:FSharpPlus.Operators.nth``2(System.Int32,``0)">
<summary>
 Gets the nth value in the foldable - i.e. at position &apos;n&apos;
</summary>
</member>
<member name="M:FSharpPlus.Operators.minBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Gets the minimum value after projecting in the foldable
</summary>
</member>
<member name="M:FSharpPlus.Operators.maxBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Gets the maximum value after projecting in the foldable
</summary>
</member>
<member name="M:FSharpPlus.Operators.minimum``2(``0)">
<summary>
 Gets the minimum value in the foldable
</summary>
</member>
<member name="M:FSharpPlus.Operators.maximum``2(``0)">
<summary>
 Gets the maximum value in the foldable
</summary>
</member>
<member name="M:FSharpPlus.Operators.length``1(``0)">
 <summary>Gets the number of elements in the foldable.</summary>
 <category index="11">Foldable</category>
 
 <param name="source">The input foldable.</param>
 <returns>The length of the foldable.</returns>
</member>
<member name="M:FSharpPlus.Operators.tryLast``2(``0)">
 <summary>Gets the last element of the foldable, or
 <c>None</c> if the foldable is empty.</summary>
 <remarks>Unsafe for infinite sequence input.</remarks>
 <param name="source">The input foldable.</param>
 <returns>The last element of the foldable or None.</returns>
</member>
<member name="M:FSharpPlus.Operators.tryHead``2(``0)">
 <summary>Gets the first element of the foldable, or
 <c>None</c> if the foldable is empty.</summary>
 <param name="source">The input foldable.</param>
 <returns>The first element of the foldable or None.</returns>
</member>
<member name="M:FSharpPlus.Operators.head``2(``0)">
 <summary>Gets the first element of the foldable.</summary>

 <param name="source">The input flodable.</param>
 <exception cref="System.ArgumentException">Thrown when the foldable is empty.</exception>
 <returns>The first element of the foldable.</returns>
</member>
<member name="M:FSharpPlus.Operators.intercalate``2(``0,``1)">
<summary>
 Folds the source, inserting a separator between each element.
</summary>
</member>
<member name="M:FSharpPlus.Operators.tryPick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``2)">
 <summary>Applies the given function to successive elements, returning <c>Some(x)</c> the first
 result where function returns <c>Some(x)</c> for some x. If no such element 
 exists then return <c>None</c>.</summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="source">The input foldable.</param>
 <returns>The first resulting value or None.</returns>
</member>
<member name="M:FSharpPlus.Operators.pick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``2)">
 <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some x. If no such
 element exists then raise <c>System.Collections.Generic.KeyNotFoundException</c></summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="source">The input foldable.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown when the foldable is empty.</exception>
 <returns>The first resulting value.</returns>
</member>
<member name="M:FSharpPlus.Operators.tryFind``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
 <summary>Gets the first element for which the given function returns true.
 Returns None if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="source">The input foldable.</param>
 <returns>The first element for which the predicate returns true, or None if
 every element evaluates to false.</returns>
</member>
<member name="M:FSharpPlus.Operators.find``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
 <summary>Gets the first element for which the given function returns true.
 Raises <c>KeyNotFoundException</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="source">The input foldable.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if the predicate evaluates to false for
 all the elements of the foldable.</exception>
 <returns>The first element that satisfies the predicate.</returns>
</member>
<member name="M:FSharpPlus.Operators.forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
 <summary>Tests if all elements of the collection satisfy the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input foldable. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="source">The input foldable.</param>
 <returns>True if all of the elements satisfy the predicate.</returns>
</member>
<member name="M:FSharpPlus.Operators.exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
 <summary>Tests if any element of the list satisfies the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input foldable. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="source">The input foldable.</param>
 <returns>True if any element satisfies the predicate.</returns>
</member>
<member name="M:FSharpPlus.Operators.toSeq``2(``0)">
 <summary>Views the given foldable as a sequence.</summary>
 <param name="source">The input foldable.</param>
 <returns>The sequence of elements in the foldable.</returns>
</member>
<member name="M:FSharpPlus.Operators.toArray``2(``0)">
 <summary>Builds an array from the given foldable.</summary>
 <param name="source">The input foldable.</param>
 <returns>The array of foldable elements.</returns>
</member>
<member name="M:FSharpPlus.Operators.toList``2(``0)">
 <summary>Builds a list from the given foldable.</summary>
 <param name="source">The input foldable.</param>
 <returns>The list of foldable elements.</returns>
</member>
<member name="M:FSharpPlus.Operators.foldMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Folds by mapping all values to a Monoid
</summary>
</member>
<member name="M:FSharpPlus.Operators.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2)">
 <summary>Applies a function to each element of the foldable, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the foldable. Then feed this result into the function along
 with the second element and so on. Return the final result.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
 computes <c>f (... (f s i0) i1 ...) iN</c>.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="foldable">The input foldable.</param>
 <returns>The final state value.</returns>
</member>
<member name="M:FSharpPlus.Operators.foldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``2,``1)">
<summary>
 Foldable
 &lt;summary&gt;Applies a function to each element of the foldable, starting from the end, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.&lt;/summary&gt;
 &lt;param name=&quot;folder&quot;&gt;The function to update the state given the input elements.&lt;/param&gt;
 &lt;param name=&quot;foldable&quot;&gt;The input foldable.&lt;/param&gt;
 &lt;param name=&quot;state&quot;&gt;The initial state.&lt;/param&gt;
 &lt;returns&gt;The state object after the folding function is applied to each element of the foldable.&lt;/returns&gt;
</summary>
</member>
<member name="M:FSharpPlus.Operators.app``1">
<summary>
 Applies an arrow produced as the output of some previous computation to an input, producing its output as the output of app.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getApp``1">
<summary>
 Applies an arrow produced as the output of some previous computation to an input, producing its output as the output of app.
</summary>
</member>
<member name="M:FSharpPlus.Operators.right``2(``0)">
<summary>
 Feeds marked inputs through the right argument arrow, passing the rest through unchanged to the output.
</summary>
</member>
<member name="M:FSharpPlus.Operators.left``2(``0)">
<summary>
 Feeds marked inputs through the left argument arrow, passing the rest through unchanged to the output.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_PlusPlusPlus``3(``0,``1)">
<summary>
 Splits the input between both argument arrows, retagging and merging their outputs. Note that this is in general not a functor.
</summary>
</member>
<member name="M:FSharpPlus.Operators.fanin``3(``0,``1)">
<summary>
 Splits the input between the two argument arrows and merge their outputs. Also known as the (|||) operator.
</summary>
</member>
<member name="M:FSharpPlus.Operators.fanout``3(``0,``1)">
<summary>
 Sends the input to both argument arrows and combine their output. Also known as the (&amp;&amp;&amp;) operator.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_MultiplyMultiplyMultiply``3(``0,``1)">
<summary>
 Splits the input between the two argument arrows and combine their output. Note that this is in general not a functor.
</summary>
</member>
<member name="M:FSharpPlus.Operators.arrSecond``2(``0)">
<summary>
 Sends the second component of the input through the argument arrow, and copy the rest unchanged to the output.
</summary>
</member>
<member name="M:FSharpPlus.Operators.arrFirst``2(``0)">
<summary>
 Sends the first component of the input through the argument arrow, and copy the rest unchanged to the output.
</summary>
</member>
<member name="M:FSharpPlus.Operators.arr``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Lifts a function to an arrow.
</summary>
</member>
<member name="M:FSharpPlus.Operators.catComp``3(``0,``1)">
<summary>
 Right-to-left morphism composition.
</summary>
</member>
<member name="M:FSharpPlus.Operators.catId``1">
<summary>
 The identity morphism.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getCatId``1">
<summary>
 Gets the identity morphism.
</summary>
</member>
<member name="M:FSharpPlus.Operators.invmap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``0},``2)">
<summary>
 Maps a pair of functions over an Invariant Functor
</summary>
</member>
<member name="M:FSharpPlus.Operators.rmap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps over the right part of a Profunctor.
</summary>
</member>
<member name="M:FSharpPlus.Operators.lmap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps over the left part of a Profunctor.
</summary>
</member>
<member name="M:FSharpPlus.Operators.dimap``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},``4)">
<summary>
 Maps over both arguments at the same time of a Profunctor.
</summary>
</member>
<member name="M:FSharpPlus.Operators.second``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps covariantly over the second argument of the Bifunctor.
</summary>
</member>
<member name="M:FSharpPlus.Operators.first``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps covariantly over the first argument of the Bifunctor.
</summary>
</member>
<member name="M:FSharpPlus.Operators.bimap``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},``4)">
<summary>
 Maps over both arguments of the Bifunctor at the same time.
</summary>
</member>
<member name="M:FSharpPlus.Operators.contramap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps over the input.
</summary>
</member>
<member name="M:FSharpPlus.Operators.guard``1(System.Boolean)">
<summary>
 Conditional failure of Alternative computations.
 If true it lifts the unit value, else it returns empty.

 Common uses of guard include conditionally signaling an error in an error monad and conditionally rejecting the current choice in an Alternative-based parser.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_LessBarGreater``1(``0,``0)">
<summary>
 Combines two Alternatives
</summary>
</member>
<member name="M:FSharpPlus.Operators.empty``1">
<summary>
 A functor representing the empty value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getEmpty``1">
<summary>
 Gets a functor representing the empty value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.plus``1(``0,``0)">
<summary>
 Combines two monoids in one.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_PlusPlus``1(``0,``0)">
<summary>
 Combines two monoids in one.
</summary>
</member>
<member name="M:FSharpPlus.Operators.zero``1">
<summary>
 A value that represents the 0 element of a Monoid.
</summary>
</member>
<member name="M:FSharpPlus.Operators.getZero``1">
<summary>
 Gets a value that represents the 0 element of a Monoid.
</summary>
</member>
<member name="M:FSharpPlus.Operators.liftM``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Equivalent to map but only for Monads.
</summary>
</member>
<member name="M:FSharpPlus.Operators.join``2(``0)">
<summary>
 Flattens two layers of monadic information into one.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``3,``2},``3)">
<summary>
 Composes right-to-left two monadic functions (Kleisli composition).
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``3,``2},``0)">
<summary>
 Composes left-to-right two monadic functions (Kleisli composition).
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Takes a function from a plain type to a monadic value and a monadic value, and returns a new monadic value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_GreaterGreaterEquals``3(``0,Microsoft.FSharp.Core.FSharpFunc{``2,``1})">
<summary>
 Takes a monadic value and a function from a plain type to a monadic value, and returns a new monadic value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Takes a function from a plain type to a monadic value and a monadic value, and returns a new monadic value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.opt``3(``0)">
<summary>
 Transforms an alternative value (which has the notion of success/failure) to an alternative
 that always succeed, wrapping the original value into an option to signify success/failure of the original alternative.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_LessMultiplyMultiplyGreater``3(``0)">
<summary>
 Apply a lifted argument to a lifted function (flipped): arg &lt;**&gt; f
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_LessMultiply``5(``0,``2)">
<summary>
 Sequences two applicatives left-to-right, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_MultiplyGreater``5(``0,``2)">
<summary>
 Sequences two applicatives left-to-right, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpPlus.Operators.lift3``8(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``4,``5,``6)">
 <summary>
 Applies 3 lifted arguments to a non-lifted function. Equivalent to map3 in non list-like types.
 </summary>
 <category index="2">Applicative</category>
</member>
<member name="M:FSharpPlus.Operators.liftA2``6(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3,``4)">
<summary>
 Apply 2 lifted arguments to a non-lifted function.
</summary>
</member>
<member name="M:FSharpPlus.Operators.lift2``6(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``3,``4)">
<summary>
 Applies 2 lifted arguments to a non-lifted function. Equivalent to map2 in non list-like types.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_LessMultiplyGreater``3(``0,``1)">
<summary>
 Apply a lifted argument to a lifted function: f &lt;*&gt; arg
</summary>
</member>
<member name="M:FSharpPlus.Operators.result``2(``0)">
<summary>
 Lifts a value into a Functor. Same as return in Computation Expressions.
</summary>
</member>
<member name="M:FSharpPlus.Operators.zip``3(``0,``1)">
<summary>
 Zips (tuple) two functors.
 For collections, if one collection is shorter, excess elements are discarded from the right end of the longer collection. 
</summary>
</member>
<member name="M:FSharpPlus.Operators.unzip``3(``0)">
<summary>
 Un-zips (un-tuple) two functors.
</summary>
</member>
<member name="M:FSharpPlus.Operators.iter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``1)">
<summary>
 Like map but ignoring the results.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_BarGreaterGreater``4(``0,Microsoft.FSharp.Core.FSharpFunc{``2,``3})">
<summary>
 Lifts a function into a Functor. Same as map but with flipped arguments.
 To be used in pipe-forward style expressions
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_LessLessBar``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Lifts a function into a Functor. Same as map.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_LessBangGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Lifts a function into a Functor. Same as map.
 To be used in Applicative Style expressions, combined with &lt;*&gt;
</summary>
</member>
<member name="M:FSharpPlus.Operators.map``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Lifts a function into a Functor.
</summary>
</member>
<member name="M:FSharpPlus.Operators.tuple8``8(``0,``1,``2,``3,``4,``5,``6,``7)">
<summary>
 Tuple eight arguments
</summary>
</member>
<member name="M:FSharpPlus.Operators.tuple7``7(``0,``1,``2,``3,``4,``5,``6)">
<summary>
 Tuple seven arguments
</summary>
</member>
<member name="M:FSharpPlus.Operators.tuple6``6(``0,``1,``2,``3,``4,``5)">
<summary>
 Tuple six arguments
</summary>
</member>
<member name="M:FSharpPlus.Operators.tuple5``5(``0,``1,``2,``3,``4)">
<summary>
 Tuple five arguments
</summary>
</member>
<member name="M:FSharpPlus.Operators.tuple4``4(``0,``1,``2,``3)">
<summary>
 Tuple four arguments
</summary>
</member>
<member name="M:FSharpPlus.Operators.tuple3``3(``0,``1,``2)">
<summary>
 Tuple three arguments
</summary>
</member>
<member name="M:FSharpPlus.Operators.tuple2``2(``0,``1)">
<summary>
 Tuple two arguments
</summary>
</member>
<member name="M:FSharpPlus.Operators.option``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``1,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Takes a function, a default value and a option value. If the option value is None, the function returns the default value.
 Otherwise, it applies the function to the value inside Some and returns the result.
</summary>
</member>
<member name="M:FSharpPlus.Operators.either``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpResult{``0,``2})">
 <summary> Extracts a value from either side of a Result.</summary>
 <param name="fOk">Function to be applied to source, if it contains an Ok value.</param>
 <param name="fError">Function to be applied to source, if it contains an Error value.</param>
 <param name="source">The source value, containing an Ok or an Error.</param>
 <returns>The result of applying either functions.</returns>
</member>
<member name="M:FSharpPlus.Operators.tap``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0)">
<summary>
 Executes a side-effect function and returns the original input value.
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_DivideGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Used in conjunction with &lt;/ to make an ad-hoc binary operator out of a function (x &lt;/f/&gt; y).
</summary>
</member>
<member name="M:FSharpPlus.Operators.op_LessDivide``2(``0)">
<summary>
 Used in conjunction with /&gt; to make an ad-hoc binary operator out of a function (x &lt;/f/&gt; y).
</summary>
</member>
<member name="M:FSharpPlus.Operators.uncurryN``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Takes a function expecting any N number of curried arguments and returns a function expecting a tuple of N elements.
</summary>
</member>
<member name="M:FSharpPlus.Operators.curryN``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
 <summary>
 Takes a function expecting a tuple of any N number of elements and returns a function expecting N curried arguments.
 </summary>
 <category index="0">Common Combinators</category>
</member>
<member name="M:FSharpPlus.Operators.uncurry``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
 <summary>
 Takes a function expecting two curried arguments and returns a function expecting a tuple of two elements. Same as (&lt;||).
 </summary>
</member>
<member name="M:FSharpPlus.Operators.curry``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},``0,``1)">
<summary>
 Takes a function expecting a tuple of two elements and returns a function expecting two curried arguments.
</summary>
</member>
<member name="M:FSharpPlus.Operators.konst``2(``0,``1)">
 <summary> Creates a constant function.</summary>
 <param name="k">The constant value.</param>
 <returns>The constant value function.</returns>
</member>
<member name="M:FSharpPlus.Operators.flip``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``1,``0)">
<summary>
 Creates a new function with first two arguments flipped.
</summary>
</member>
<member name="M:FSharpPlus.Operators.Arrows.op_BitwiseOr``3(``0,``1)">
<summary>
 Splits the input between the two argument arrows and merge their outputs. Also known as fanin.
</summary>
</member>
<member name="M:FSharpPlus.Operators.Arrows.op_BitwiseAnd``3(``0,``1)">
<summary>
 Sends the input to both argument arrows and combine their output. Also known as fanout.
</summary>
</member>
<member name="M:FSharpPlus.Operators.Arrows.op_RightShift``3(``0,``1)">
<summary>
 Left-to-right morphism composition.
</summary>
</member>
<member name="M:FSharpPlus.Operators.Arrows.op_LeftShift``3(``0,``1)">
<summary>
 Right-to-left morphism composition.
</summary>
</member>
<member name="T:FSharpPlus.Operators.Arrows">
 <summary>Additional operators for Arrows related functions which shadows some F# operators for bitwise functions.</summary>
</member>
<member name="M:FSharpPlus.Operators.Seq.sum``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Folds all values in the sequence using the monoidal addition.
</summary>
</member>
<member name="T:FSharpPlus.Operators">
<summary>
 Generic functions and operators
</summary>
</member>
<member name="T:FSharpPlus.Math.Applicative">
 <summary>Math Operators ready to use over Applicative Functors.</summary>
</member>
<member name="M:FSharpPlus.Math.Generic.gcd``1(``0,``0)">
<summary>
 Greatest Common Divisor.
</summary>
</member>
<member name="M:FSharpPlus.Math.Generic.divRemE``1(``0,``0)">
<summary>
 Euclidean division-remainder, following the mathematical convention where the mod is always positive.
</summary>
</member>
<member name="M:FSharpPlus.Math.Generic.remE``1(``0,``0)">
<summary>
 Euclidean remainder of integer division, following the mathematical convention where the mod is always positive.
</summary>
</member>
<member name="M:FSharpPlus.Math.Generic.rem``1(``0,``0)">
<summary>
 Remainder of Integer division. Same as (%).
</summary>
</member>
<member name="M:FSharpPlus.Math.Generic.divE``1(``0,``0)">
<summary>
 Euclidean integer division, following the mathematical convention where the mod is always positive.
</summary>
</member>
<member name="M:FSharpPlus.Math.Generic.div``1(``0,``0)">
<summary>
 Integer division. Same as (/) for Integral types.
</summary>
</member>
<member name="T:FSharpPlus.Math.Generic">
 <summary>
 Generic numbers, functions and operators.
 By opening this module some common operators become restricted, like (+) to 'T->'T->'T
 </summary>
</member>
<member name="P:FSharpPlus.GenericBuilders.MonadFxBuilder`1.plus'">
<summary>
 Makes it a strict monadplus computation expression.
</summary>
</member>
<member name="P:FSharpPlus.GenericBuilders.MonadFxBuilder`1.plus">
<summary>
 Makes it a (lazy) monadplus computation expression.
</summary>
</member>
<member name="P:FSharpPlus.GenericBuilders.MonadFxBuilder`1.fx'">
<summary>
 Makes it a strict monadic computation expression with side-effects
</summary>
</member>
<member name="P:FSharpPlus.GenericBuilders.MonadFxBuilder`1.fx">
<summary>
 Makes it a (lazy) monadic computation expression with side-effects
</summary>
</member>
<member name="M:FSharpPlus.GenericBuilders.monad'``1">
<summary>
 Creates a strict monadic computation expression with side-effects (see http://fsprojects.github.io/FSharpPlus/computation-expressions.html for more information)
</summary>
</member>
<member name="M:FSharpPlus.GenericBuilders.monad``1">
<summary>
 Creates a (lazy) monadic computation expression with side-effects (see http://fsprojects.github.io/FSharpPlus/computation-expressions.html for more information)
</summary>
</member>
<member name="T:FSharpPlus.GenericBuilders">
<summary>
 Constructs to express generic computations
</summary>
</member>
<member name="M:FSharpPlus.Lens.op_LessAmpGreater``4(``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
 <summary>An infix flipped map, restricted to non-primitive types.</summary>
 <param name="x">The functor.</param>
 <param name="f">The mapper function.</param>
 <returns>The mapped Functor.</returns>
</member>
<member name="M:FSharpPlus.Lens.op_HatDotDot``5(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,FSharpPlus.Data.Const{FSharpPlus.Data.Endo{Microsoft.FSharp.Collections.FSharpList{``1}},``2}},Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Const{FSharpPlus.Data.Endo{Microsoft.FSharp.Collections.FSharpList{``3}},``4}}})">
<summary>
 Extract a list of the targets of a Fold. Same as ``toListOf`` but with the arguments flipped.
</summary>
</member>
<member name="M:FSharpPlus.Lens.op_HatQmark``5(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,FSharpPlus.Data.Const{FSharpPlus.Data.First{``1},``2}},Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Const{FSharpPlus.Data.First{``3},``4}}})">
 <summary>Retrieve the first value targeted by a Prism, Fold or Traversal (or Some result from a Getter or Lens). Same as ``preview`` but with the arguments flipped.</summary>
 <param name="prism">The prism.</param>
 <param name="source">The object.</param>
 <returns>The value (if any) the prism is targeting.</returns>
</member>
<member name="M:FSharpPlus.Lens.op_PercentMinusGreater``4(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Identity{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpPlus.Data.Identity{``3}}},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Update a value in a lens. Same as ``over``.</summary>
 <param name="lens">The lens.</param>
 <param name="updater">A function that converts the value we want to write in the part targeted by the lens.</param>
 <returns>The new object with the value modified.</returns>
</member>
<member name="M:FSharpPlus.Lens.op_DotMinusGreater``4(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Identity{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpPlus.Data.Identity{``3}}},``1)">
 <summary>Write to a lens. Same as ``setl``.</summary>
 <param name="lens">The lens.</param>
 <param name="value">The value we want to write in the part targeted by the lens.</param>
 <returns>The new object with the value modified.</returns>
</member>
<member name="M:FSharpPlus.Lens.op_HatDot``5(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,FSharpPlus.Data.Const{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Const{``3,``4}}})">
 <summary>Read from a lens. Same as ``view`` but with the arguments flipped.</summary>
 <param name="lens">The lens.</param>
 <param name="source">The object.</param>
 <returns>The part the lens is targeting.</returns>
</member>
<member name="M:FSharpPlus.Lens.minimumOf``5(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Const{FSharpPlus.Data.Dual{FSharpPlus.Data.Endo{Microsoft.FSharp.Core.FSharpOption{``0}}},``1}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpPlus.Data.Const{FSharpPlus.Data.Dual{FSharpPlus.Data.Endo{Microsoft.FSharp.Core.FSharpOption{``3}}},``4}}})">
<summary>
 Get the smallest target of a Fold.
</summary>
</member>
<member name="M:FSharpPlus.Lens.maximumOf``5(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Const{FSharpPlus.Data.Dual{FSharpPlus.Data.Endo{Microsoft.FSharp.Core.FSharpOption{``0}}},``1}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpPlus.Data.Const{FSharpPlus.Data.Dual{FSharpPlus.Data.Endo{Microsoft.FSharp.Core.FSharpOption{``3}}},``4}}})">
<summary>
 Get the largest target of a Fold.
</summary>
</member>
<member name="M:FSharpPlus.Lens.toListOf``5(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Const{FSharpPlus.Data.Endo{Microsoft.FSharp.Collections.FSharpList{``0}},``1}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpPlus.Data.Const{FSharpPlus.Data.Endo{Microsoft.FSharp.Collections.FSharpList{``3}},``4}}})">
<summary>
 Extract a list of the targets of a Fold. See also (^..).
</summary>
</member>
<member name="M:FSharpPlus.Lens._None``4(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Prism providing a Traversal for targeting the &apos;None&apos; part of an Option&lt;&apos;T&gt;
</summary>
</member>
<member name="M:FSharpPlus.Lens._Some``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Prism providing a Traversal for targeting the &apos;Some&apos; part of an Option&lt;&apos;T&gt;
</summary>
</member>
<member name="M:FSharpPlus.Lens._Error``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Prism providing a Traversal for targeting the &apos;Error&apos; part of a Result&lt;&apos;T,&apos;Error&gt;
</summary>
</member>
<member name="M:FSharpPlus.Lens._Ok``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Prism providing a Traversal for targeting the &apos;Ok&apos; part of a Result&lt;&apos;T,&apos;Error&gt;
</summary>
</member>
<member name="M:FSharpPlus.Lens.non``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Lens for the value inside an Option or the given default value if the Option is None.  Works well when combined with Map._item
</summary>
</member>
<member name="M:FSharpPlus.Lens._5``7(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``5)">
<summary>
 Lens for the fifth element of a tuple
</summary>
</member>
<member name="M:FSharpPlus.Lens._4``7(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``5)">
<summary>
 Lens for the fourth element of a tuple
</summary>
</member>
<member name="M:FSharpPlus.Lens._3``7(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``5)">
<summary>
 Lens for the third element of a tuple
</summary>
</member>
<member name="M:FSharpPlus.Lens._2``7(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``5)">
<summary>
 Lens for the second element of a tuple
</summary>
</member>
<member name="M:FSharpPlus.Lens._1``7(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``5)">
<summary>
 Lens for the first element of a tuple
</summary>
</member>
<member name="M:FSharpPlus.Lens.choosing``10(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``4,``8},Microsoft.FSharp.Core.FSharpFunc{``0,``6}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``4,``8},Microsoft.FSharp.Core.FSharpFunc{``2,``7}},Microsoft.FSharp.Core.FSharpFunc{``4,``8},Microsoft.FSharp.Core.FSharpResult{``2,``0})">
<summary>
 Merge two lenses, getters, setters, folds or traversals.
 &lt;param name=&quot;optic1&quot;&gt;The first optic.&lt;/param&gt;
 &lt;param name=&quot;optic2&quot;&gt;The second optic.&lt;/param&gt;
 &lt;param name=&quot;f&quot;&gt;The free parameter.&lt;/param&gt;
 &lt;returns&gt;An optic for a Result which uses the first optic for the Ok and the second for the Error.&lt;/returns&gt;
</summary>
</member>
<member name="M:FSharpPlus.Lens.iso``8(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3})">
 <summary>Build an 'Iso' from a pair of inverse functions.</summary>
 <param name="func">The transform function.</param>
 <param name="inv">The inverse of the transform function.</param>
 <returns>The iso.</returns>
</member>
<member name="M:FSharpPlus.Lens.prism'``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}},Microsoft.FSharp.Core.FSharpFunc{``2,``3})">
 <summary>Build a 'Prism' from a constructor and a getter.</summary>
 <remarks>The prism should be assigned as an inline function of the free parameter, not a value, otherwise compiler will fail with a type constraint mismatch.</remarks>
 <remarks>Using Option which makes 's and 't the same type.</remarks>
 <param name="constructor">The constructor function.</param>
 <param name="getter">The getter function, having as first parameter the object and second the value to set.</param>
 <param name="f">The free parameter.</param>
 <returns>The prism.</returns>
</member>
<member name="M:FSharpPlus.Lens.prism``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpResult{``3,``1}},Microsoft.FSharp.Core.FSharpFunc{``3,``4})">
 <summary>Build a 'Prism' from a constructor and a getter.</summary>
 <remarks>The prism should be assigned as an inline function of the free parameter, not a value, otherwise compiler will fail with a type constraint mismatch.</remarks>
 <remarks>Using Result instead of Option to permit the types of 's and 't to differ.</remarks>
 <param name="constructor">The constructor function.</param>
 <param name="getter">The getter function, having as first parameter the object and second the value to set.</param>
 <param name="f">The free parameter.</param>
 <returns>The prism.</returns>
</member>
<member name="M:FSharpPlus.Lens.lens``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Microsoft.FSharp.Core.FSharpFunc{``1,``4},``0)">
 <summary>Build a 'Lens' from a getter and a setter.</summary>
 <remarks>The lens should be assigned as an inline function of the free parameter, not a value, otherwise compiler will fail with a type constraint mismatch.</remarks>
 <param name="getter">The getter function.</param>
 <param name="setter">The setter function, having as first parameter the object and second the value to set.</param>
 <param name="f">The free parameter.</param>
 <param name="s"></param>
 <returns>The lens.</returns>
</member>
<member name="M:FSharpPlus.Lens.preview``5(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Const{FSharpPlus.Data.First{``0},``1}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpPlus.Data.Const{FSharpPlus.Data.First{``3},``4}}})">
 <summary>Retrieve the first value targeted by a Prism, Fold or Traversal (or Some result from a Getter or Lens). See also (^?).</summary>
 <param name="prism">The prism.</param>
 <param name="source">The object.</param>
 <returns>The value (if any) the prism is targeting.</returns>
</member>
<member name="M:FSharpPlus.Lens.view``5(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Const{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpPlus.Data.Const{``3,``4}}})">
 <summary>Read from a lens.</summary>
 <param name="lens">The lens.</param>
 <param name="source">The object.</param>
 <returns>The part the lens is targeting.</returns>
</member>
<member name="M:FSharpPlus.Lens.over``4(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Identity{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpPlus.Data.Identity{``3}}},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Update a value in a lens.</summary>
 <param name="lens">The lens.</param>
 <param name="f">A function that converts the value we want to write in the part targeted by the lens.</param>
 <param name="source">The original object.</param>
 <returns>The new object with the value modified.</returns>
</member>
<member name="M:FSharpPlus.Lens.setl``4(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Identity{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpPlus.Data.Identity{``3}}},``1)">
 <summary>Write to a lens.</summary>
 <param name="lens">The lens.</param>
 <param name="v">The value we want to write in the part targeted by the lens.</param>
 <param name="source">The original object.</param>
 <returns>The new object with the value modified.</returns>
</member>
<member name="M:FSharpPlus.Lens.IReadOnlyDictionary._item``4(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},``2},System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
<summary>
 Given a specific key, produces a Lens from a IReadOnlyDictionary&lt;key, value&gt; to an Option&lt;value&gt;.  When setting,
 a Some(value) will insert or replace the value into the dictionary at the given key.  Setting a value of
 None will delete the value at the specified key.  Works well together with non.
</summary>
</member>
<member name="M:FSharpPlus.Lens.Map._item``4(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},``2},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Given a specific key, produces a Lens from a Map&lt;key, value&gt; to an Option&lt;value&gt;.  When setting,
 a Some(value) will insert or replace the value into the map at the given key.  Setting a value of
 None will delete the value at the specified key.  Works well together with non.
</summary>
</member>
<member name="M:FSharpPlus.Lens.Array._item``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},``1},``0[])">
<summary>
 Given a specific key, produces a Lens from a Array&lt;value&gt; to an Option&lt;value&gt;.
</summary>
</member>
<member name="M:FSharpPlus.Lens.List._item``3(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Given a specific key, produces a Lens from a List&lt;value&gt; to an Option&lt;value&gt;. When setting,
 a Some(value) will insert or replace the value into the list at the given index. Setting a value of
 None will delete the value at the specified index.  Works well together with non.
</summary>
</member>
<member name="T:FSharpPlus.Lens.Internals">
<summary>
 [omit]
</summary>
</member>
<member name="T:FSharpPlus.Lens">
<summary>
 Lens functions and operators
</summary>
</member>
<member name="T:FSharpPlus.Data.neseq`1">
<summary>
 A type alias for NonEmptySeq&lt;&apos;t&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.NonEmptySeq`1">
<summary>
 A type-safe sequence that contains at least one element.
</summary>
</member>
<member name="T:FSharpPlus.Data.Identity`1">
 <summary> Computation type: Simple function application.
 <para/>   Binding strategy: The bound function is applied to the input value. Identity x >>= f = Identity (f x)
 <para/>   Useful for: Lens setters and updaters - Monads can be derived from monad transformers applied to the Identity monad.
 <para/>   The Identity monad is a monad that does not embody any computational strategy. 
           It simply applies the bound function to its input without any modification. 
           Computationally, there is no reason to use the Identity monad instead of the much simpler act of simply applying functions to their arguments.
           The purpose of the Identity monad is its fundamental role in the theory of monad transformers.
           Any monad transformer applied to the Identity monad yields a non-transformer version of that monad.
           Its applicative instance plays a fundamental role in Lens. </summary> 
</member>
<member name="T:FSharpPlus.Data.ListT`1">
<summary>
 Monad Transformer for list&lt;&apos;T&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.SeqT`1">
<summary>
 Monad Transformer for seq&lt;&apos;T&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.OptionT`1">
<summary>
 Monad Transformer for Option&lt;&apos;T&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.ResultT`1">
<summary>
 Monad Transformer for Result&lt;&apos;T, &apos;E&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.ContT`2">
<summary>
 Monad Transformer for Cont&lt;&apos;R,&apos;T&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.Cont`2">
 <summary> Computation type: Computations which can be interrupted and resumed.
 <para/>   Binding strategy: Binding a function to a monadic value creates a new continuation which uses the function as the continuation of the monadic computation.
 <para/>   Useful for: Complex control structures, error handling, and creating co-routines.</summary>
</member>
<member name="T:FSharpPlus.Data.ReaderT`2">
<summary>
 Monad Transformer for Reader&lt;&apos;R, &apos;T&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.Reader`2">
 <summary> Computation type: Computations which read values from a shared environment.
 <para/>   Binding strategy: Monad values are functions from the environment to a value. The bound function is applied to the bound value, and both have access to the shared environment.
 <para/>   Useful for: Maintaining variable bindings, or other shared environment.</summary>
</member>
<member name="T:FSharpPlus.Data.WriterT`1">
<summary>
 Monad Transformer for Writer&lt;&apos;Monoid, &apos;T&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.Writer`2">
 <summary> Computation type: Computations which produce a stream of data in addition to the computed values.
 <para/>   Binding strategy: Combines the outputs of the subcomputations using <c>mappend</c>.
 <para/>   Useful for: Logging, or other computations that produce output "on the side". </summary>
</member>
<member name="T:FSharpPlus.Data.StateT`2">
<summary>
 Monad Transformer for State&lt;&apos;S, &apos;T&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.State`2">
 <summary> Computation type: Computations which maintain state.
 <para>   Binding strategy: Threads a state parameter through the sequence of bound functions so that the same state value is never used twice, giving the illusion of in-place update.</para>
 <para>   Useful for: Building computations from sequences of operations that require a shared state.</para>
 The <typeparamref name="'s"/> indicates the computation state, while <typeparamref name="'t"/> indicates the result.</summary>
</member>
<member name="T:FSharpPlus.Data.Compose`1">
<summary>
 Right-to-left composition of functors. The composition of applicative functors is always applicative, but the composition of monads is not always a monad.
</summary>
</member>
<member name="T:FSharpPlus.Data.Mult`1">
<summary>
 Numeric wrapper for multiplication monoid (*, 1)
</summary>
</member>
<member name="T:FSharpPlus.Data.Last`1">
<summary>
 Option&lt;&apos;T&gt; monoid returning the rightmost non-None value.
</summary>
</member>
<member name="T:FSharpPlus.Data.First`1">
<summary>
 Option&lt;&apos;T&gt; monoid returning the leftmost non-None value.
</summary>
</member>
<member name="T:FSharpPlus.Data.Const`2">
 <summary> The Const functor, defined as Const&lt;&#39;T, &#39;U&gt; where &#39;U is a phantom type. Useful for: Lens getters Its applicative instance plays a fundamental role in Lens.
 <para/>   Useful for: Lens getters.
 <para/>   Its applicative instance plays a fundamental role in Lens. </summary>
</member>
<member name="T:FSharpPlus.Data.Any">
<summary>
 Boolean monoid under disjunction.
</summary>
</member>
<member name="T:FSharpPlus.Data.All">
<summary>
 Boolean monoid under conjunction.
</summary>
</member>
<member name="T:FSharpPlus.Data.Endo`1">
<summary>
 The monoid of endomorphisms under composition.
</summary>
</member>
<member name="T:FSharpPlus.Data.Dual`1">
<summary>
 The dual of a monoid, obtained by swapping the arguments of append.
</summary>
</member>
<member name="T:FSharpPlus.Data.MultiMap`2">
<summary>
 A Map where keys are not unique.
</summary>
</member>
<member name="T:FSharpPlus.Data.nelist`1">
<summary>
 A type alias for NonEmptyList&lt;&apos;t&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.NonEmptyList`1">
<summary>
 A type-safe list that contains at least one element.
</summary>
</member>
<member name="T:FSharpPlus.Data.neset`1">
<summary>
 A type alias for NonEmptySet&lt;&apos;t&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.NonEmptySet`1">
<summary>
 A type-safe set that contains at least one element.
</summary>
</member>
<member name="T:FSharpPlus.Data.nemap`2">
<summary>
 A type alias for NonEmptyMap&lt;&apos;Key,&apos;Value&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.NonEmptyMap`2">
<summary>
 A type-safe map that contains at least one element.
</summary>
</member>
<member name="T:FSharpPlus.Data.ZipList`1">
<summary>
 A sequence with an Applicative functor based on zipping.
</summary>
</member>
<member name="T:FSharpPlus.Data.parray`1">
<summary>
 A type alias for ParallelArray&lt;&apos;T&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.ParallelArray`1">
<summary>
 Array with an Applicative functor based on zipping and parallel execution.
</summary>
</member>
<member name="P:FSharpPlus.Data.DList`1.Uncons">
<summary>
 O(log n). Returns the first element and tail.
</summary>
</member>
<member name="P:FSharpPlus.Data.DList`1.TryUncons">
<summary>
 O(log n). Returns option first element and tail.
</summary>
</member>
<member name="P:FSharpPlus.Data.DList`1.TryTail">
<summary>
 O(log n). Returns option DList of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpPlus.Data.DList`1.TryHead">
<summary>
 O(log n). Returns option first element
</summary>
</member>
<member name="P:FSharpPlus.Data.DList`1.Tail">
<summary>
 O(log n). Returns a new DList of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpPlus.Data.DList`1.Length">
<summary>
 O(1). Returns the count of elememts.
</summary>
</member>
<member name="P:FSharpPlus.Data.DList`1.IsEmpty">
<summary>
 O(1). Returns true if the DList has no elements.
</summary>
</member>
<member name="P:FSharpPlus.Data.DList`1.Head">
<summary>
 O(log n). Returns the first element.
</summary>
</member>
<member name="M:FSharpPlus.Data.DList`1.Cons(`0)">
<summary>
 O(1). Returns a new DList with the element added to the front.
</summary>
</member>
<member name="M:FSharpPlus.Data.DList`1.Add(`0)">
<summary>
 O(1). Returns a new DList with the element added to the end.
</summary>
</member>
<member name="T:FSharpPlus.Data.DList`1">
<summary>
 DList is an ordered linear structure implementing the List signature (head, tail, cons), 
 end-insertion (add), and O(1) append. Ordering is by insertion history.
 DList is an implementation of [John Hughes&apos; append list](http://dl.acm.org/citation.cfm?id=8475).
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation`2.SequenceBiApply``2(FSharpPlus.Data.Validation{``0,``1}[])">
<summary>
 Creates an array with either all Success values or the Failure ones.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation`2.SequenceBiApply``2(Microsoft.FSharp.Collections.FSharpList{FSharpPlus.Data.Validation{``0,``1}})">
<summary>
 Creates a list with either all Success values or the Failure ones.
</summary>
</member>
<member name="T:FSharpPlus.Data.Validation`2">
<summary>
 A &apos;Validation&apos; is either a value of the type &apos;error or &apos;t, similar to &apos;Result&apos;. However,
 the &apos;Applicative&apos; instance for &apos;Validation&apos; accumulates errors using a &apos;Semigroup&apos; on &apos;error.
 In contrast, the Applicative for &apos;Result&apos; returns only the first error.

 A consequence of this is that &apos;Validation&apos; is not a monad. There is no F#+ &apos;Bind&apos; method since
 that would violate monad rules.
</summary>
</member>
<member name="T:FSharpPlus.Data.Kleisli`2">
<summary>
 Kleisli arrows of a monad. Represents a function &apos;T -&gt; &apos;Monad&lt;&apos;U&gt;
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.lift3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},FSharpPlus.Data.NonEmptySeq{``2},FSharpPlus.Data.NonEmptySeq{``0},FSharpPlus.Data.NonEmptySeq{``1})">
 <summary>Combines values from three NonEmptySeq and calls a mapping function on this combination.</summary>
 <param name="f">Mapping function taking three element combination as input.</param>
 <param name="x1">First NonEmptySeq.</param>
 <param name="x2">Second NonEmptySeq.</param>
 <param name="x3">Third NonEmptySeq.</param>

 <returns>NonEmptySeq with values returned from mapping function.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.NonEmptySeq{``1}},FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Applies the given function to each element of the NonEmptySequence and concatenates all the
 results.</summary>

 <remarks>Remember NonEmptySequence is lazy, effects are delayed until it is enumerated.</remarks>
 <remarks>This is the same as Seq.collect but the type of the mapping function is not flexible.</remarks>

 <param name="mapping">A function to transform elements of the input NonEmptySequence into the NonEmptySequences
 that will then be concatenated.</param>
 <param name="source">The input NonEmptySequence.</param>

 <returns>The result NonEmptySequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input NonEmptySequence is null.</exception>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.zip3``3(FSharpPlus.Data.NonEmptySeq{``0},FSharpPlus.Data.NonEmptySeq{``1},FSharpPlus.Data.NonEmptySeq{``2})">
 <summary>Combines the three sequences into a list of triples. The sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequences are ignored.</summary>

 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>
 <param name="source3">The third input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.zip``2(FSharpPlus.Data.NonEmptySeq{``0},FSharpPlus.Data.NonEmptySeq{``1})">
 <summary>Combines the two sequences into a list of pairs. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.</summary>

 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.tail``1(FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Returns a sequence that skips 1 element of the underlying sequence and then yields the
 remaining elements of the sequence.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.sortByDescending``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Applies a key-generating function to each element of a sequence and yield a sequence ordered
 descending by keys.    The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.</summary> 
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="projection">A function to transform items of the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.sortDescending``1(FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Yields a sequence ordered descending by keys.</summary>
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Applies a key-generating function to each element of a sequence and yield a sequence ordered
 by keys.    The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.</summary> 
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="projection">A function to transform items of the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.sortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Yields a sequence ordered using the given comparison function.</summary>
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences. The function makes no assumption on the ordering of the original
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>
 <param name="comparer">The function to compare the collection elements.</param>
 <param name="source">The input sequence.</param>
 <returns>The result sequence.</returns>
 <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.sort``1(FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Yields a sequence ordered by keys.</summary>
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.singleton``1(``0)">
 <summary>Returns a sequence that yields one item only.</summary>

 <param name="value">The input item.</param>

 <returns>The result sequence of one item.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.scanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpPlus.Data.NonEmptySeq{``0},``1)">
 <summary>Like <c>foldBack</c>, but returns the sequence of intermediary and final results.</summary>
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as that
 sequence is iterated. As a result this function should not be used with large or infinite sequences.
 </remarks>
 <param name="folder">A function that updates the state with each element from the sequence.</param>
 <param name="source">The input sequence.</param>
 <param name="state">The initial state.</param>
 <returns>The resulting sequence of computed states.</returns>
 <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpPlus.Data.NonEmptySeq{``1})">
 <summary>Like fold, but computes on-demand and returns the sequence of intermediary and final results.</summary>

 <param name="folder">A function that updates the state with each element from the sequence.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input sequence.</param>

 <returns>The resulting sequence of computed states.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.rev``1(FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Returns a new sequence with the elements in reverse order.</summary>
 <param name="source">The input sequence.</param>
 <returns>The reversed sequence.</returns>
 <remarks>This function consumes the whole input sequence before yielding the first element of the reversed sequence.</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.readonly``1(FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Builds a new sequence object that delegates to the given sequence object. This ensures 
 the original sequence cannot be rediscovered and mutated by a type cast. For example, 
 if given an array the returned sequence will return the elements of the array, but
 you cannot cast the returned sequence object to an array.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.permute``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Returns a sequence with all elements permuted according to the
 specified permutation.</summary>

 <remarks>Note that this function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences.</remarks>

 <param name="indexMap">The function that maps input indices to output indices.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentException">Thrown when indexMap does not produce a valid permutation.</exception>
 <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.pairwise``1(FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Returns a sequence of each element in the input sequence and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.tryOfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Transforms a list to a NonEmptySeq, returning an option to signal when the original list was empty.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a non empty sequence from the given list.</summary>
 <param name="list">The input list.</param>
 <returns>Non empty sequence containing the elements of the list.</returns>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <remarks>Throws exception for empty list</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.tryOfArray``1(``0[])">
<summary>
 Transforms a array to a NonEmptySeq, returning an option to signal when the original array was empty.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.ofArray``1(``0[])">
 <summary>Builds a non empty sequence from the given array.</summary>
 <param name="array">The input array.</param>
 <returns>Non empty sequence containing the elements of the list.</returns>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <remarks>Throws exception for empty array</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.tryOfSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Transforms a sequence to a NonEmptySeq, returning an option to signal when the original sequence was empty.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a non empty sequence from the given sequence.</summary>
 <param name="seq">The input sequence.</param>
 <returns>Non empty sequence containing the elements of the list.</returns>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
 <remarks>
   Throws exception for empty sequence.
 
   Evaluates the first element of the sequence and may trigger side effects.
   If you are sure that the sequence is not empty and want to avoid that, you can use `unsafeOfSeq` instead.
 </remarks>
 <seealso cref="unsafeOfSeq" />
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},FSharpPlus.Data.NonEmptySeq{``0},FSharpPlus.Data.NonEmptySeq{``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored. The integer index passed to the
 function indicates the index (from 0) of element being transformed.</summary>

 <param name="mapping">A function to transform pairs of items from the input sequences that also supplies the current index.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.</summary>

 <param name="mapping">A function to transform items from the input sequence that also supplies the current index.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},FSharpPlus.Data.NonEmptySeq{``0},FSharpPlus.Data.NonEmptySeq{``1},FSharpPlus.Data.NonEmptySeq{``2})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding triples of elements from the three sequences. If one input sequence if shorter than
 the others then the remaining elements of the longer sequences are ignored.</summary>

 <param name="mapping">The function to transform triples of elements from the input sequences.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>
 <param name="source3">The third input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.mapFoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},FSharpPlus.Data.NonEmptySeq{``0},``1)">
 <summary>Combines map and foldBack. Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The function is also used to accumulate a final value.</summary>
 <remarks>This function digests the whole initial sequence as soon as it is called. As a result this function should
 not be used with large or infinite sequences.</remarks>
 <param name="mapping">The function to transform elements from the input collection and accumulate the final value.</param>
 <param name="source">The input collection.</param>
 <param name="state">The initial state.</param>
 <returns>The collection of transformed elements, and the final accumulated value.</returns>
 <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.mapFold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``0}}},``0,FSharpPlus.Data.NonEmptySeq{``1})">
 <summary>Combines map and fold. Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The function is also used to accumulate a final value.</summary>
 <remarks>This function digests the whole initial sequence as soon as it is called. As a result this function should
 not be used with large or infinite sequences.</remarks>
 <param name="mapping">The function to transform elements from the input collection and accumulate the final value.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input collection.</param>
 <returns>The collection of transformed elements, and the final accumulated value.</returns>
 <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpPlus.Data.NonEmptySeq{``0},FSharpPlus.Data.NonEmptySeq{``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.</summary>

 <param name="mapping">A function to transform pairs of items from the input sequences.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.    The given function will be applied
 as elements are demanded using the <c>MoveNext</c> method on enumerators retrieved from the
 object.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>

 <param name="mapping">A function to transform items from the input sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.initInfinite``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Generates a new sequence which, when iterated, will return successive
 elements by calling the given function.    The results of calling the function
 will not be saved, that is the function will be reapplied as necessary to
 regenerate the elements.    The function is passed the index of the item being
 generated.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
 Iteration can continue up to <c>Int32.MaxValue</c>.</remarks>

 <param name="initializer">A function that generates an item in the sequence from a given index.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.indexed``1(FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Builds a new collection whose elements are the corresponding elements of the input collection
 paired with the integer index (from 0) of each element.</summary>
 <param name="source">The input sequence.</param>
 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.head``1(FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Returns the first element of the sequence.</summary>

 <param name="source">The input sequence.</param>

 <returns>The first element of the sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.delay``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,FSharpPlus.Data.NonEmptySeq{``0}})">
 <summary>Returns a sequence that is built from the given delayed specification of a
 sequence.</summary>

 <remarks>The input function is evaluated each time an IEnumerator for the sequence 
 is requested.</remarks>

 <param name="generator">The generating function for the sequence.</param>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.concat``2(FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Combines the given enumeration-of-enumerations as a single concatenated
 enumeration.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>

 <param name="sources">The input enumeration-of-enumerations.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.collect``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Applies the given function to each element of the sequence and concatenates all the
 results.</summary>

 <remarks>Remember sequence is lazy, effects are delayed until it is enumerated.</remarks>

 <param name="mapping">A function to transform elements of the input sequence into the sequences
 that will then be concatenated.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.cache``1(FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Returns a sequence that corresponds to a cached version of the input sequence.
 This result sequence will have the same elements as the input sequence. The result 
 can be enumerated multiple times. The input sequence will be enumerated at most 
 once and only as far as is necessary.    Caching a sequence is typically useful when repeatedly
 evaluating items in the original sequence is computationally expensive or if
 iterating the sequence causes side-effects that the user does not want to be
 repeated multiple times.

 Enumeration of the result sequence is thread safe in the sense that multiple independent IEnumerator
 values may be used simultaneously from different threads (accesses to 
 the internal lookaside table are thread safe). Each individual IEnumerator
 is not typically thread safe and should not be accessed concurrently.</summary>

 <remarks>Once enumeration of the input sequence has started,
 it's enumerator will be kept live by this object until the enumeration has completed.
 At that point, the enumerator will be disposed. 

 The enumerator may be disposed and underlying cache storage released by 
 converting the returned sequence object to type IDisposable, and calling the Dispose method
 on this object. The sequence object may then be re-enumerated and a fresh enumerator will
 be used.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.append``1(FSharpPlus.Data.NonEmptySeq{``0},FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Wraps the two given enumerations as a single concatenated
 enumeration.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed
 concurrently.</remarks>

 <param name="source1">The first sequence.</param>
 <param name="source2">The second sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.allPairs``2(FSharpPlus.Data.NonEmptySeq{``0},FSharpPlus.Data.NonEmptySeq{``1})">
 <summary>Returns a new sequence that contains all pairings of elements from the first and second sequences.</summary>
 <param name="source1">The first sequence.</param>
 <param name="source2">The second sequence.</param>
 <returns>The result sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.op_DotDotBar(System.Int32,System.Int32)">
<summary>
 Creates a NonEmptySeq range, containing at least the last element of the range
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.op_BarDotDot(System.Int32,System.Int32)">
<summary>
 Creates a NonEmptySeq range, containing at least the first element of the range
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.create``1(``0,System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a non empty sequence.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySeq.unsafeOfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a non empty sequence from the given sequence.</summary>
 <param name="seq">The input sequence.</param>
 <returns>Non empty sequence containing the elements of the list.</returns>
 <remarks>
   **This function does not check whether the sequence is actually non empty or not.**
 
   Use this function only if you are sure that the sequence is not empty and
   you don't want to evaluate the first element of the sequence which would cause a
   side effect.
  
   Otherwise, always use `ofSeq`. 
 </remarks>
 <seealso cref="ofSeq" />
</member>
<member name="T:FSharpPlus.Data.Identity">
<summary>
 Basic operations on Identity
</summary>
</member>
<member name="M:FSharpPlus.Data.ListT.lift``4(``0)">
<summary>
 Embed a Monad&lt;&apos;T&gt; into a ListT&lt;&apos;Monad&lt;list&lt;&apos;T&gt;&gt;&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.ListT">
<summary>
 Basic operations on ListT
</summary>
</member>
<member name="T:FSharpPlus.Data.List">
<summary>
 Additional operations on List
</summary>
</member>
<member name="M:FSharpPlus.Data.SeqT.lift``4(``0)">
<summary>
 Embed a Monad&lt;&apos;T&gt; into a SeqT&lt;&apos;Monad&lt;seq&lt;&apos;T&gt;&gt;&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.SeqT">
<summary>
 Basic operations on SeqT
</summary>
</member>
<member name="T:FSharpPlus.Data.Seq">
<summary>
 Additional operations on Seq
</summary>
</member>
<member name="M:FSharpPlus.Data.OptionT.hoist``2(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Transform an option&lt;&apos;T,&apos;Error&gt; to an OptionT&lt;&apos;Monad&lt;option&lt;&apos;T,&apos;Error&gt;&gt;&gt;
</summary>
</member>
<member name="M:FSharpPlus.Data.OptionT.lift``4(``0)">
<summary>
 Embed a Monad&lt;&apos;T&gt; into an OptionT&lt;&apos;Monad&lt;option&lt;&apos;T&gt;&gt;&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.OptionT">
<summary>
 Basic operations on OptionT
</summary>
</member>
<member name="T:FSharpPlus.Data.Option">
<summary>
 Additional operations on Option
</summary>
</member>
<member name="M:FSharpPlus.Data.ChoiceT.hoist``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Transform a Choice&lt;&apos;T,&apos;Error&gt; to a ChoiceT&lt;&apos;Monad&lt;Choice&lt;&apos;T,&apos;Error&gt;&gt;&gt;
</summary>
</member>
<member name="M:FSharpPlus.Data.ChoiceT.lift``6(``0)">
<summary>
 Embed a Monad&lt;&apos;T&gt; into a ChoiceT&lt;&apos;Monad&lt;Choice&lt;&apos;T,&apos;Error&gt;&gt;&gt;
</summary>
</member>
<member name="M:FSharpPlus.Data.ResultT.hoist``3(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
<summary>
 Transform a Result&lt;&apos;T,&apos;Error&gt; to a ResultT&lt;&apos;Monad&lt;Result&lt;&apos;T,&apos;Error&gt;&gt;&gt;
</summary>
</member>
<member name="M:FSharpPlus.Data.ResultT.lift``6(``0)">
<summary>
 Embed a Monad&lt;&apos;T&gt; into a ChoiceT&lt;&apos;Monad&lt;Choice&lt;&apos;T,&apos;Error&gt;&gt;&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.ResultT">
<summary>
 Basic operations on ResultT
</summary>
</member>
<member name="T:FSharpPlus.Data.ResultOrException">
<summary>
 Result&lt;&apos;TSuccess,&apos;TFailure&gt; specialized in &apos;TFailure = Exception 
</summary>
</member>
<member name="T:FSharpPlus.Data.Result">
<summary>
 Additional operations on Result
</summary>
</member>
<member name="M:FSharpPlus.Data.ContT.eval``2(FSharpPlus.Data.Cont{``0,``1})">
<summary>
 The result of running a CPS computation with its inner monad&apos;s &apos;Return&apos; function as the final continuation.
</summary>
</member>
<member name="M:FSharpPlus.Data.ContT.run``2(FSharpPlus.Data.Cont{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``0})">
<summary>
 The result of running a CPS computation with the identity function as the final continuation.
</summary>
</member>
<member name="T:FSharpPlus.Data.ContT">
<summary>
 Basic operations on ContT
</summary>
</member>
<member name="M:FSharpPlus.Data.Cont.callCC``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Cont{``1,``2}},FSharpPlus.Data.Cont{``1,``0}})">
<summary>
 (call-with-current-continuation) calls a function with the current continuation as its argument.
</summary>
</member>
<member name="M:FSharpPlus.Data.Cont.eval``1(FSharpPlus.Data.Cont{``0,``0})">
<summary>
 The result of running a CPS computation with the identity function as the final continuation.
</summary>
</member>
<member name="M:FSharpPlus.Data.Cont.run``2(FSharpPlus.Data.Cont{``0,``1})">
<summary>
 The result of running a CPS computation with a given final continuation.
</summary>
</member>
<member name="T:FSharpPlus.Data.Cont">
<summary>
 Basic operations on Cont
</summary>
</member>
<member name="M:FSharpPlus.Data.ReaderT.lift``2(``0)">
<summary>
 Embed a Monad&lt;&apos;T&gt; into an ReaderT&lt;&apos;R, &apos;Monad&lt;&apos;T&gt;&gt;
</summary>
</member>
<member name="M:FSharpPlus.Data.ReaderT.zip``7(FSharpPlus.Data.ReaderT{``0,``1},FSharpPlus.Data.ReaderT{``0,``5})">
<summary>
 Zips two ReaderTs into one.
</summary>
</member>
<member name="M:FSharpPlus.Data.ReaderT.map3``9(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},FSharpPlus.Data.ReaderT{``4,``5},FSharpPlus.Data.ReaderT{``4,``6},FSharpPlus.Data.ReaderT{``4,``7})">
<summary>
 Combines three ReaderTs into one by applying a mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Data.ReaderT.map2``7(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpPlus.Data.ReaderT{``3,``4},FSharpPlus.Data.ReaderT{``3,``5})">
<summary>
 Combines two ReaderTs into one by applying a mapping function.
</summary>
</member>
<member name="T:FSharpPlus.Data.ReaderT">
<summary>
 Basic operations on Reader
</summary>
</member>
<member name="M:FSharpPlus.Data.Reader.local``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.Reader{``1,``2})">
 <summary> Executes a computation in a modified environment. </summary>
 <param name="f"> The function to modify the environment.    </param>
 <param name="m"> Reader to run in the modified environment. </param>
</member>
<member name="M:FSharpPlus.Data.Reader.ask``1">
<summary>
 Retrieves the monad environment.
</summary>
</member>
<member name="M:FSharpPlus.Data.Reader.zip``3(FSharpPlus.Data.Reader{``0,``1},FSharpPlus.Data.Reader{``0,``2})">
<summary>
 Zips two Readers into one.
</summary>
</member>
<member name="M:FSharpPlus.Data.Reader.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},FSharpPlus.Data.Reader{``4,``0},FSharpPlus.Data.Reader{``4,``1},FSharpPlus.Data.Reader{``4,``2})">
<summary>
 Combines three Readers into one by applying a mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Data.Reader.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpPlus.Data.Reader{``3,``0},FSharpPlus.Data.Reader{``3,``1})">
<summary>
 Combines two Readers into one by applying a mapping function.
</summary>
</member>
<member name="T:FSharpPlus.Data.Reader">
<summary>
 Basic operations on Reader
</summary>
</member>
<member name="M:FSharpPlus.Data.WriterT.map3``9(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},FSharpPlus.Data.WriterT{``4},FSharpPlus.Data.WriterT{``5},FSharpPlus.Data.WriterT{``6})">
<summary>
 Combines three WriterTs into one by applying a mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Data.WriterT.map2``7(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpPlus.Data.WriterT{``3},FSharpPlus.Data.WriterT{``4})">
<summary>
 Combines two WriterTs into one by applying a mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Data.WriterT.lift``6(``0)">
<summary>
 Embed a Monad&lt;&apos;T&gt; into a WriterT&lt;&apos;Monad&lt;&apos;T * &apos;Monoid&gt;&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.WriterT">
<summary>
 Basic operations on WriterT
</summary>
</member>
<member name="M:FSharpPlus.Data.Writer.pass``2(FSharpPlus.Data.Writer{``0,System.Tuple{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}})">
<summary>
 Action that executes the action m, which returns a value and a function, and returns the value, applying the function to the output.
</summary>
</member>
<member name="M:FSharpPlus.Data.Writer.listen``2(FSharpPlus.Data.Writer{``0,``1})">
 <summary> An action that executes the action <paramref name="m"/> and adds its output
 to the value of the computation. </summary>
 <param name="m">The action to be executed.</param>
</member>
<member name="M:FSharpPlus.Data.Writer.tell``1(``0)">
<summary>
 Embeds a simple writer action.
</summary>
</member>
<member name="M:FSharpPlus.Data.Writer.exec``2(FSharpPlus.Data.Writer{``0,``1})">
<summary>
 Extract the output from a writer computation.
</summary>
</member>
<member name="M:FSharpPlus.Data.Writer.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},FSharpPlus.Data.Writer{``4,``0},FSharpPlus.Data.Writer{``4,``1},FSharpPlus.Data.Writer{``4,``2})">
<summary>
 Combines three Writers into one by applying a mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Data.Writer.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpPlus.Data.Writer{``3,``0},FSharpPlus.Data.Writer{``3,``1})">
<summary>
 Combines two Writers into one by applying a mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Data.Writer.run``2(FSharpPlus.Data.Writer{``0,``1})">
<summary>
 Unwraps a writer computation as a (result, output) pair. (The inverse of Writer.)
</summary>
</member>
<member name="T:FSharpPlus.Data.Writer">
<summary>
 Basic operations on Writer
</summary>
</member>
<member name="M:FSharpPlus.Data.StateT.zip``10(FSharpPlus.Data.StateT{``0,``1},FSharpPlus.Data.StateT{``0,``9})">
<summary>
 Zips two StateTs into one.
</summary>
</member>
<member name="M:FSharpPlus.Data.StateT.map3``10(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},FSharpPlus.Data.StateT{``4,``5},FSharpPlus.Data.StateT{``4,``7},FSharpPlus.Data.StateT{``4,``8})">
<summary>
 Combines three StateTs into one by applying a mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Data.StateT.map2``8(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpPlus.Data.StateT{``3,``4},FSharpPlus.Data.StateT{``3,``6})">
<summary>
 Combines two StateTs into one by applying a mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Data.StateT.hoist``3(FSharpPlus.Data.State{``0,``1})">
<summary>
 Transform a State&lt;&apos;S, &apos;T&gt; to a StateT&lt;&apos;S, &apos;``Monad&lt;&apos;T * &apos;S&gt;``&gt;
</summary>
</member>
<member name="M:FSharpPlus.Data.StateT.lift``5(``0)">
<summary>
 Embed a Monad&lt;&apos;T&gt; into a StateT&lt;&apos;S,&apos;``Monad&lt;&apos;T * &apos;S&gt;``&gt;
</summary>
</member>
<member name="M:FSharpPlus.Data.StateT.run``2(FSharpPlus.Data.StateT{``0,``1})">
<summary>
 Runs the state with an inital state to get back the result and the new state wrapped in an inner monad.
</summary>
</member>
<member name="T:FSharpPlus.Data.StateT">
<summary>
 Basic operations on StateT
</summary>
</member>
<member name="M:FSharpPlus.Data.State.zip``3(FSharpPlus.Data.State{``0,``1},FSharpPlus.Data.State{``0,``2})">
<summary>
 Zips two States into one.
</summary>
</member>
<member name="M:FSharpPlus.Data.State.modify``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 Modify the state inside the monad by applying a function.
</summary>
</member>
<member name="M:FSharpPlus.Data.State.put``1(``0)">
<summary>
 Replace the state inside the monad.
</summary>
</member>
<member name="M:FSharpPlus.Data.State.gets``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Get a value which depends on the current state.
</summary>
</member>
<member name="M:FSharpPlus.Data.State.get``1">
<summary>
 Return the state from the internals of the monad.
</summary>
</member>
<member name="M:FSharpPlus.Data.State.exec``2(FSharpPlus.Data.State{``0,``1},``0)">
<summary>
 Evaluates a &lt;paramref name=&quot;sa&quot;&gt;state computation&lt;/paramref&gt; with the &lt;paramref name=&quot;s&quot;&gt;initial value&lt;/paramref&gt; and return only the final state of the computation. Ignore the result value.
</summary>
</member>
<member name="M:FSharpPlus.Data.State.eval``2(FSharpPlus.Data.State{``0,``1},``0)">
<summary>
 Evaluates a &lt;paramref name=&quot;sa&quot;&gt;state computation&lt;/paramref&gt; with the &lt;paramref name=&quot;s&quot;&gt;initial value&lt;/paramref&gt; and return only the result value of the computation. Ignore the final state.
</summary>
</member>
<member name="M:FSharpPlus.Data.State.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},FSharpPlus.Data.State{``4,``0},FSharpPlus.Data.State{``4,``1},FSharpPlus.Data.State{``4,``2})">
<summary>
 Combines three States into one by applying a mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Data.State.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpPlus.Data.State{``3,``0},FSharpPlus.Data.State{``3,``1})">
<summary>
 Combines two States into one by applying a mapping function.
</summary>
</member>
<member name="M:FSharpPlus.Data.State.run``2(FSharpPlus.Data.State{``0,``1})">
<summary>
 Runs the state with an inital state to get back the result and the new state.
</summary>
</member>
<member name="T:FSharpPlus.Data.State">
<summary>
 Basic operations on State
</summary>
</member>
<member name="T:FSharpPlus.Data.Compose">
<summary>
 Basic operations on Compose
</summary>
</member>
<member name="T:FSharpPlus.Data.Const">
<summary>
 Basic operations on Const
</summary>
</member>
<member name="T:FSharpPlus.Data.Endo">
<summary>
 Basic operations on Endo
</summary>
</member>
<member name="T:FSharpPlus.Data.Dual">
<summary>
 Basic operations on Dual
</summary>
</member>
<member name="M:FSharpPlus.Data.MultiMap.mapValues``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.MultiMap{``2,``0})">
<summary>
 Maps values of the original multiMap.
</summary>
</member>
<member name="M:FSharpPlus.Data.MultiMap.add``2(``0,``1,FSharpPlus.Data.MultiMap{``0,``1})">
<summary>
 Returns a new multiMap with the new binding added to the given multiMap.
</summary>
</member>
<member name="M:FSharpPlus.Data.MultiMap.toArray``2(FSharpPlus.Data.MultiMap{``0,``1})">
<summary>
 Converts a multiMap to an array of tuples.
</summary>
</member>
<member name="M:FSharpPlus.Data.MultiMap.toList``2(FSharpPlus.Data.MultiMap{``0,``1})">
<summary>
 Converts a multiMap to a list of tuples.
</summary>
</member>
<member name="M:FSharpPlus.Data.MultiMap.toSeq``2(FSharpPlus.Data.MultiMap{``0,``1})">
<summary>
 Converts a multiMap to a seq of tuples.
</summary>
</member>
<member name="M:FSharpPlus.Data.MultiMap.ofArray``2(System.Tuple{``0,``1}[])">
<summary>
 Converts an array of tuples to a multiMap.
</summary>
</member>
<member name="M:FSharpPlus.Data.MultiMap.ofList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Converts a list of tuples to a multiMap.
</summary>
</member>
<member name="M:FSharpPlus.Data.MultiMap.ofSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Converts a seq of tuples to a multiMap.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.tryOfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Transforms a list to a NonEmptyList, returning an option to signal when the original list was empty.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.choice``1(FSharpPlus.Data.NonEmptyList{``0})">
<summary>
 Reduces using alternative operator `&lt;|&gt;`.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.range``1(``0,``0)">
<summary>
 Equivalent to [start..stop] on regular lists.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.minBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Returns the lowest of all elements of the list, compared via Operators.min on the function result</summary>
 <param name="projection">The function to transform list elements into the type to be compared.</param>
 <param name="list">The input list.</param>
 <returns>The minimum value.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.min``1(FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Returns the lowest of all elements of the list, compared via Operators.min.</summary>
 <param name="list">The input list.</param>
 <returns>The minimum value.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.maxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Returns the greatest of all elements of the list, compared via Operators.max on the function result.</summary>
 <param name="projection">The function to transform the list elements into the type to be compared.</param>
 <param name="list">The input list.</param>
 <returns>The maximum element.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.max``1(FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Returns the greatest of all elements of the list, compared via Operators.max.</summary>
 <param name="list">The input list.</param>
 <returns>The maximum element.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.reduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Applies a function to each element of the list, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN-1 iN))</c>.</summary>
 <param name="reduction">A function that takes in the next-to-last element of the list and the
 current accumulated result to produce the next accumulated result.</param>
 <param name="list">The input list.</param>
 <returns>The final result of the reductions.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Applies a function to each element of the list, threading an accumulator argument
 through the computation. Apply the function to the first two elements of the list.
 Then feed this result into the function along with the third element and so on. 
 Return the final result. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f i0 i1) i2 ...) iN</c>.</summary>
 <param name="reduction">The function to reduce two list elements to a single element.</param>
 <param name="list">The input list.</param>
 <returns>The final reduced value.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.averageBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Returns the average of the elements generated by applying the function to each element of the list.</summary>
 <param name="projection">The function to transform the list elements into the type to be averaged.</param>
 <param name="list">The input list.</param>
 <returns>The resulting average.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.average``1(FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Returns the average of the elements in the list.</summary>
 <param name="list">The input list.</param>
 <returns>The resulting average.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.tail``1(FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Returns a new NonEmptyList of the elements trailing the first element.</summary>
 <exception cref="System.ArgumentException">Thrown when the tail is empty.</exception>
 <remarks>Throws exception for empty tail</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.head``1(FSharpPlus.Data.NonEmptyList{``0})">
<summary>
 Returns the first element of a new non empty list. You can also use property nel.Head.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.cons``1(``0,FSharpPlus.Data.NonEmptyList{``0})">
<summary>
 Returns a new NonEmptyList with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.zipShortest``2(FSharpPlus.Data.NonEmptyList{``0},FSharpPlus.Data.NonEmptyList{``1})">
 <summary>
 Zip safely two lists. If one list is shorter, excess elements are discarded from the right end of the longer list. 
 </summary>
 <param name="list1">First input list.</param>
 <param name="list2">Second input list.</param>
 <returns>List with corresponding pairs of input lists.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.zip``2(FSharpPlus.Data.NonEmptyList{``0},FSharpPlus.Data.NonEmptyList{``1})">
 <summary>Combines the two lists into a list of pairs. The two lists must have equal lengths.</summary>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <returns>A single list containing pairs of matching elements from the input lists.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.unzip``2(FSharpPlus.Data.NonEmptyList{System.Tuple{``0,``1}})">
 <summary>Splits a list of pairs into two lists.</summary>
 <param name="list">The input list.</param>
 <returns>Two lists of split elements.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Build a new non empty list whose elements are the results of applying the given function with index
 to each of the elements of the non empty list.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.map2Shortest``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpPlus.Data.NonEmptyList{``0},FSharpPlus.Data.NonEmptyList{``1})">
 <summary>Safely build a new non empty list whose elements are the results of applying the given function
 to each of the elements of the two non empty list pairwise.</summary>
 <remark>If one list is shorter, excess elements are discarded from the right end of the longer list.</remark>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Build a new non empty list whose elements are the results of applying the given function
 to each of the elements of the non empty list.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.length``1(FSharpPlus.Data.NonEmptyList{``0})">
<summary>
 Returns the length of a non empty list. You can also use property nel.Length.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a non empty list from the given sequence.</summary>
 <param name="seq">The input list.</param>
 <returns>Non empty list containing the elements of the list.</returns>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <remarks>Throws exception for empty list</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a non empty list from the given list.</summary>
 <param name="list">The input list.</param>
 <returns>Non empty list containing the elements of the list.</returns>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <remarks>Throws exception for empty list</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.ofArray``1(``0[])">
 <summary>Builds a non empty list from the given array.</summary>
 <param name="array">The input array.</param>
 <returns>Non empty list containing the elements of the array.</returns>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <remarks>Throws exception for empty array</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.toArray``1(FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Builds an array from the given non empty list.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.toSeq``1(FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Builds a sequence from the given non empty list.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.toList``1(FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Builds a list from the given non empty list.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.singleton``1(``0)">
 <summary>Builds a non empty list with a single element.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyList.create``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a non empty list.</summary>
</member>
<member name="T:FSharpPlus.Data.NonEmptyList">
<summary>
 Basic operations on NonEmptyList
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpPlus.Data.NonEmptySet{``0},``1)">
 <summary>Applies the given accumulating function to all the elements of the set.</summary>
 <param name="folder">The accumulating function.</param>
 <param name="set">The input set.</param>
 <param name="state">The initial state.</param>
 <returns>The final state.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpPlus.Data.NonEmptySet{``1})">
 <summary>Applies the given accumulating function to all the elements of the set</summary>
 <param name="folder">The accumulating function.</param>
 <param name="state">The initial state.</param>
 <param name="set">The input set.</param>
 <returns>The final state.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.maxElement``1(FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Returns the highest element in the set according to the ordering being used for the set.</summary>
 <param name="set">The input set.</param>
 <returns>The max value from the set.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.minElement``1(FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Returns the lowest element in the set according to the ordering being used for the set.</summary>
 <param name="set">The input set.</param>
 <returns>The min value from the set.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Applies the given function to each element of the set, in order according
 to the comparison function.</summary>
 <param name="action">The function to apply to each element.</param>
 <param name="set">The input set.</param>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.unionMany``1(FSharpPlus.Data.NonEmptyList{FSharpPlus.Data.NonEmptySet{``0}})">
 <summary>Computes the union of a non empty list of sets.</summary>
 <param name="sets">The sequence of sets to union.</param>
 <returns>The union of the input sets.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.union``1(FSharpPlus.Data.NonEmptySet{``0},FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Computes the union of the two sets.</summary>
 <param name="set1">The first input set.</param>
 <param name="set2">The second input set.</param>
 <returns>The union of <c>set1</c> and <c>set2</c>.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Tests if all elements of the collection satisfy the given predicate.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and "j0...jN"
 then computes <c>p i0 &amp;&amp; ... &amp;&amp; p iN</c>.</summary>
 <param name="predicate">The function to test set elements.</param>
 <param name="set">The input set.</param>
 <returns>True if all elements of <c>set</c> satisfy <c>predicate</c>.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Returns a new collection containing the results of applying the
 given function to each element of the input set.</summary>
 <param name="mapping">The function to transform elements of the input set.</param>
 <param name="set">The input set.</param>
 <returns>A set containing the transformed elements.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Tests if any element of the collection satisfies the given predicate.
 If the input function is <c>predicate</c> and the elements are <c>i0...iN</c>
 then computes <c>p i0 or ... or p iN</c>.</summary>
 <param name="predicate">The function to test set elements.</param>
 <param name="set">The input set.</param>
 <returns>True if any element of <c>set</c> satisfies <c>predicate</c>.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.isProperSuperset``1(FSharpPlus.Data.NonEmptySet{``0},FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Evaluates to "true" if all elements of the second set are in the first, and at least
 one element of the first is not in the second.</summary>
 <param name="set1">The potential superset.</param>
 <param name="set2">The set to test against.</param>
 <returns>True if <c>set1</c> is a proper superset of <c>set2</c>.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.isSuperset``1(FSharpPlus.Data.NonEmptySet{``0},FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Evaluates to "true" if all elements of the second set are in the first.</summary>
 <param name="set1">The potential superset.</param>
 <param name="set2">The set to test against.</param>
 <returns>True if <c>set1</c> is a superset of <c>set2</c>.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.isProperSubset``1(FSharpPlus.Data.NonEmptySet{``0},FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Evaluates to "true" if all elements of the first set are in the second, and at least
 one element of the second is not in the first.</summary>
 <param name="set1">The potential subset.</param>
 <param name="set2">The set to test against.</param>
 <returns>True if <c>set1</c> is a proper subset of <c>set2</c>.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.isSubset``1(FSharpPlus.Data.NonEmptySet{``0},FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Evaluates to "true" if all elements of the first set are in the second</summary>
 <param name="set1">The potential subset.</param>
 <param name="set2">The set to test against.</param>
 <returns>True if <c>set1</c> is a subset of <c>set2</c>.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.contains``1(``0,FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Evaluates to "true" if the given element is in the given set.</summary>
 <param name="element">The element to test.</param>
 <param name="source">The input set.</param>
 <returns>True if <c>element</c> is in <c>set</c>.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.add``1(``0,FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Returns a new set with an element added to the set. No exception is raised if
 the set already contains the given element.</summary>
 <param name="value">The value to add.</param>
 <param name="source">The input set.</param>
 <returns>A new set containing <c>value</c>.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.count``1(FSharpPlus.Data.NonEmptySet{``0})">
<summary>
 Returns the count of a non empty set. You can also use property nes.Count
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.tryOfSet``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Transforms a set to a NonEmptySet, returning an option to signal when the original set was empty.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.ofSet``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Builds a non empty set from the given set.</summary>
 <param name="set">The input set.</param>
 <returns>Non empty set containing the elements of the set.</returns>
 <exception cref="System.ArgumentException">Thrown when the input set is empty.</exception>
 <remarks>Throws exception for empty set</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.ofNonEmptySeq``1(FSharpPlus.Data.NonEmptySeq{``0})">
 <summary>Builds a non empty set from the given non-empty sequence.</summary>
 <param name="source">The input sequence.</param>
 <returns>Non empty set containing the elements of the non-empty sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a non empty set from the given sequence.</summary>
 <param name="seq">The input list.</param>
 <returns>Non empty set containing the elements of the list.</returns>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <remarks>Throws exception for empty sequence</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.ofNonEmptyList``1(FSharpPlus.Data.NonEmptyList{``0})">
 <summary>Builds a non empty set from the given non-empty list.</summary>
 <param name="list">The input list.</param>
 <returns>Non empty set containing the elements of the non-empty list.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a non empty set from the given list.</summary>
 <param name="list">The input list.</param>
 <returns>Non empty set containing the elements of the list.</returns>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <remarks>Throws exception for empty list</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.ofArray``1(``0[])">
 <summary>Builds a non empty set from the given array.</summary>
 <param name="array">The input array.</param>
 <returns>Non empty set containing the elements of the array.</returns>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <remarks>Throws exception for empty array</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.toNonEmptySeq``1(FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Builds a non-empty sequence from the given non empty set.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.toNonEmptyList``1(FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Builds a non-empty list from the given non empty set.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.toSet``1(FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Builds a set from the given non empty set.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.toArray``1(FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Builds an array from the given non empty set.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.toSeq``1(FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Builds a sequence from the given non empty set.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.toList``1(FSharpPlus.Data.NonEmptySet{``0})">
 <summary>Builds a list from the given non empty set.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.singleton``1(``0)">
 <summary>Builds a non empty set with a single element.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptySet.create``1(``0,System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a non empty set.</summary>
</member>
<member name="T:FSharpPlus.Data.NonEmptySet">
<summary>
 Basic operations on NonEmptySet
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.union``2(FSharpPlus.Data.NonEmptyMap{``0,``1},FSharpPlus.Data.NonEmptyMap{``0,``1})">
<summary>
 Returns the union of two maps, preferring values from the first in case of duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.unionWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},FSharpPlus.Data.NonEmptyMap{``1,``0},FSharpPlus.Data.NonEmptyMap{``1,``0})">
<summary>
 Returns the union of two maps, using the combiner function for duplicate keys.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.mapValues``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.NonEmptyMap{``2,``0})">
 <summary>Map values of the original Map.</summary>
 <remarks>Keys remain unchanged.</remarks>
 <param name="f">The mapping function.</param>
 <param name="x">The input Map.</param>

 <returns>The mapped Map.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.count``2(FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>The number of bindings in the map.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.tryFindKey``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Returns the key of the first mapping in the collection that satisfies the given predicate.
 Returns 'None' if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>
 <returns>The first key for which the predicate returns true or None if the predicate evaluates to false for each key/value pair.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.findKey``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Evaluates the function on each mapping in the collection. Returns the key for the first mapping
 where the function returns 'true'. Raise <c>KeyNotFoundException</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if the key does not exist in the map.</exception>
 <returns>The first key for which the predicate evaluates true.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.tryFind``2(``0,FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Lookup an element in the map, returning a <c>Some</c> value if the element is in the domain
 of the map and <c>None</c> if not.</summary>
 <param name="key">The input key.</param>
 <param name="table">The input map.</param>
 <returns>The found <c>Some</c> value or <c>None</c>.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.containsKey``2(``0,FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Tests if an element is in the domain of the map.</summary>
 <param name="key">The input key.</param>
 <param name="table">The input map.</param>
 <returns>True if the map contains the key.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The key passed to the
 function indicates the key of element being transformed.</summary>
 <param name="mapping">The function to transform the key/value pairs.</param>
 <param name="table">The input map.</param>
 <returns>The resulting map of keys and transformed values.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Returns true if the given predicate returns true for all of the
 bindings in the map.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>
 <returns>True if the predicate evaluates to true for all of the bindings in the map.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Returns true if the given predicate returns true for one of the
 bindings in the map.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>
 <returns>True if the predicate returns true for one of the key/value pairs.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.iter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Applies the given function to each binding in the dictionary</summary>
 <param name="action">The function to apply to each key/value pair.</param>
 <param name="table">The input map.</param>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,FSharpPlus.Data.NonEmptyMap{``1,``2})">
 <summary>Folds over the bindings in the map </summary>
 <param name="folder">The function to update the state given the input key/value pairs.</param>
 <param name="state">The initial state.</param>
 <param name="table">The input map.</param>
 <returns>The final state value.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.foldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},FSharpPlus.Data.NonEmptyMap{``0,``1},``2)">
 <summary>Folds over the bindings in the map.</summary>
 <param name="folder">The function to update the state given the input key/value pairs.</param>
 <param name="table">The input map.</param>
 <param name="state">The initial state.</param>
 <returns>The final state value.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.pick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Searches the map looking for the first element where the given function returns a <c>Some</c> value</summary>
 <param name="chooser">The function to generate options from the key/value pairs.</param>
 <param name="table">The input map.</param>
 <returns>The first result.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.tryPick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Searches the map looking for the first element where the given function returns a <c>Some</c> value.</summary>
 <param name="chooser">The function to generate options from the key/value pairs.</param>
 <param name="table">The input map.</param>
 <returns>The first result.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.find``2(``0,FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Lookup an element in the map, raising <c>KeyNotFoundException</c> if no binding
 exists in the map.</summary>
 <param name="key">The input key.</param>
 <param name="table">The input map.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown when the key does not exist in the map.</exception>
 <returns>The value mapped to the given key.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.tryOfMap``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Transforms a map to a NonEmptyMap, returning an option to signal when the original map was empty.
</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.ofMap``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Builds a non empty map from the given map.</summary>
 <param name="map">The input map.</param>
 <returns>Non empty map containing the elements of the map.</returns>
 <exception cref="System.ArgumentException">Thrown when the input map is empty.</exception>
 <remarks>Throws exception for empty map</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.ofNonEmptySeq``2(FSharpPlus.Data.NonEmptySeq{System.Tuple{``0,``1}})">
 <summary>Builds a non empty map from the given non-empty sequence.</summary>
 <param name="source">The input sequence.</param>
 <returns>Non empty map containing the elements of the non-empty sequence.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.ofSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
 <summary>Builds a non empty map from the given sequence.</summary>
 <param name="seq">The input list.</param>
 <returns>Non empty map containing the elements of the list.</returns>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <remarks>Throws exception for empty sequence</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.ofNonEmptyList``2(FSharpPlus.Data.NonEmptyList{System.Tuple{``0,``1}})">
 <summary>Builds a non empty map from the given non-empty list.</summary>
 <param name="list">The input list.</param>
 <returns>Non empty map containing the elements of the non-empty list.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.ofList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
 <summary>Builds a non empty map from the given list.</summary>
 <param name="list">The input list.</param>
 <returns>Non empty map containing the elements of the list.</returns>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <remarks>Throws exception for empty list</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.ofArray``2(System.Tuple{``0,``1}[])">
 <summary>Builds a non empty map from the given array.</summary>
 <param name="array">The input array.</param>
 <returns>Non empty map containing the elements of the array.</returns>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <remarks>Throws exception for empty array</remarks>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.toMap``2(FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Builds a map from the given non empty map.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.toArray``2(FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Builds an array from the given non empty map.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.toNonEmptySeq``2(FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Builds a non-empty sequence from the given non empty map.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.toSeq``2(FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Builds a sequence from the given non empty map.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.toNonEmptyList``2(FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Builds a non-empty list from the given non empty map.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.toList``2(FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Builds a list from the given non empty map.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.add``2(``0,``1,FSharpPlus.Data.NonEmptyMap{``0,``1})">
 <summary>Returns a new map with the binding added to the given map.
 If a binding with the given key already exists in the input map, the existing binding is replaced by the new binding in the result map.</summary>
 <param name="key">The input key.</param>
 <param name="value">The input value.</param>
 <param name="table">The input map.</param>
 <returns>The resulting map.</returns>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.singleton``2(``0,``1)">
 <summary>Builds a non empty map with a single element.</summary>
</member>
<member name="M:FSharpPlus.Data.NonEmptyMap.create``2(``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
 <summary>Builds a non empty map.</summary>
</member>
<member name="T:FSharpPlus.Data.NonEmptyMap">
<summary>
 Basic operations on NonEmptyMap
</summary>
</member>
<member name="M:FSharpPlus.Data.ZipList.zip``2(FSharpPlus.Data.ZipList{``0},FSharpPlus.Data.ZipList{``1})">
 <summary>Combines the two lists into a list of pairs. The two lists need not have equal lengths:
 when one list is exhausted any remaining elements in the other
 list are ignored.</summary>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <returns>A single list containing pairs of matching elements from the input lists.</returns>
</member>
<member name="T:FSharpPlus.Data.ZipList">
<summary>
 Basic operations on ZipList
</summary>
</member>
<member name="M:FSharpPlus.Data.ParallelArrayOperators.parray``1(``0[])">
<summary>
 Creates a parallel array from a normal array.
</summary>
</member>
<member name="T:FSharpPlus.Data.ParallelArray">
<summary>
 Basic operations on ParallelArray
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.toSeq``1(FSharpPlus.Data.DList{``0})">
<summary>
 O(n). Returns a seq of the DList elements.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.toList``1(FSharpPlus.Data.DList{``0})">
<summary>
 O(n). Returns a list of the DList elements.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 O(n). Returns a DList of the seq.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.tryUncons``1(FSharpPlus.Data.DList{``0})">
<summary>
 O(log n). Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.uncons``1(FSharpPlus.Data.DList{``0})">
<summary>
 O(log n). Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.tryTail``1(FSharpPlus.Data.DList{``0})">
<summary>
 O(log n). Returns option DList of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.tail``1(FSharpPlus.Data.DList{``0})">
<summary>
 O(log n). Returns a new DList of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.add``1(``0,FSharpPlus.Data.DList{``0})">
<summary>
 O(1). Returns a new DList with the element added to the end.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.singleton``1(``0)">
<summary>
 O(1). Returns DList of one elements.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.length``1(FSharpPlus.Data.DList{``0})">
<summary>
 O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.isEmpty``1(FSharpPlus.Data.DList{``0})">
<summary>
 O(1). Returns true if the DList has no elements.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.tryHead``1(FSharpPlus.Data.DList{``0})">
<summary>
 O(log n). Returns option first element.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.head``1(FSharpPlus.Data.DList{``0})">
<summary>
 O(log n). Returns the first element.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpPlus.Data.DList{``0},``1)">
<summary>
 O(n). Fold walks the DList using constant stack space. Implementation is from Norman Ramsey.
 See http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5334068#5334068
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.empty``1">
<summary>
 O(1). Returns DList of no elements.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.cons``1(``0,FSharpPlus.Data.DList{``0})">
<summary>
 O(1). Returns a new DList with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpPlus.Data.DListModule.append``1(FSharpPlus.Data.DList{``0},FSharpPlus.Data.DList{``0})">
<summary>
 O(1). Returns a new DList of two lists.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.partition``2(Microsoft.FSharp.Collections.FSharpList{FSharpPlus.Data.Validation{``0,``1}})">
 <summary>
 Creates two lists by classifying the values depending on whether they were wrapped with Success or Failure.
 </summary>
 <returns>
 A tuple with both resulting lists, Success are in the first list.
 </returns>
</member>
<member name="M:FSharpPlus.Data.Validation.protect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Creates a safe version of the supplied function, which returns a Validation&lt;exn,&apos;U&gt; instead of throwing exceptions.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.validationNel``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
<summary>
 validationNel : Result&lt;&apos;a,&apos;e&gt; -&gt; Validation (NonEmptyList&lt;&apos;e&gt;) a
 This is &apos;liftError&apos; specialized to &apos;NonEmptyList&apos;, since
 they are a common semigroup to use.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.either``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},FSharpPlus.Data.Validation{``2,``0})">
 <summary> Extracts a value from either side of a Validation.</summary>
 <param name="fSuccess">Function to be applied to source, if it contains a Success value.</param>
 <param name="fFailure">Function to be applied to source, if it contains a Failure value.</param>
 <param name="source">The source value, containing a Success or a Failure.</param>
 <returns>The result of applying either functions.</returns>
</member>
<member name="M:FSharpPlus.Data.Validation.ofChoice``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Creates a Validation&lt;&apos;Error,&apos;T&gt; from a Choice&lt;&apos;T,&apos;Error&gt;.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.toChoice``2(FSharpPlus.Data.Validation{``0,``1})">
<summary>
 Converts a Validation&lt;&apos;Error,&apos;T&gt; to a Choice&lt;&apos;T,&apos;Error&gt;.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.ofResult``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
<summary>
 Creates a Validation&lt;&apos;Error,&apos;T&gt; from a Result&lt;&apos;T,&apos;Error&gt;.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.toResult``2(FSharpPlus.Data.Validation{``0,``1})">
<summary>
 Converts a Validation&lt;&apos;Error,&apos;T&gt; to a Result&lt;&apos;T,&apos;Error&gt;.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.appValidation``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},FSharpPlus.Data.Validation{``0,``1},FSharpPlus.Data.Validation{``0,``1})">
<summary>
 Takes two Validations and returns the first Success.
 If both are Failures it returns both Failures combined with the supplied function.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.liftChoice``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Converting a &apos;Choice&apos; to a &apos;Validation&apos;
 when the &apos;Choice2Of2&apos; of the &apos;Choice&apos; needs to be lifted into a &apos;Semigroup&apos;.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.liftResult``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpResult{``2,``0})">
<summary>
 Converts a &apos;Result&apos; to a &apos;Validation&apos;
 when the &apos;Error&apos; of the &apos;Result&apos; needs to be lifted into a &apos;Semigroup&apos;.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.defaultWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.Validation{``0,``1})">
<summary>
 Extracts the Success value or applies the compensation function over the Failure.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.defaultValue``2(``0,FSharpPlus.Data.Validation{``1,``0})">
<summary>
 Extracts the Success value or use the supplied default value when it&apos;s a Failure.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,FSharpPlus.Data.Validation{``1,``2}},FSharpPlus.Data.Validation{``1,``0})">
<summary>
 Binds through a Validation, which is useful for
 composing Validations sequentially. Note that despite having a bind
 function of the correct type, Validation is not a monad.
 The reason is, this bind does not accumulate errors, so it does not
 agree with the Applicative instance.

 There is nothing wrong with using this function, it just does not make a
 valid Monad instance.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.bisequence``5(FSharpPlus.Data.Validation{``0,``2})">
<summary>
 Like sequence but traversing the Failure part as well.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.bitraverse``7(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``6,``3},FSharpPlus.Data.Validation{``0,``6})">
<summary>
 Like traverse but taking an additional function to traverse the Failure part as well.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.sequence``4(FSharpPlus.Data.Validation{``0,``1})">
<summary>
 Traverse the Success case.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.traverse``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpPlus.Data.Validation{``4,``0})">
<summary>
 Traverse the Success case with the supplied function.
</summary>
</member>
<member name="M:FSharpPlus.Data.Validation.apply``3(FSharpPlus.Data.Validation{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpPlus.Data.Validation{``0,``1})">
<summary>
 Applies the wrapped value to the wrapped function when both are Success and returns a wrapped result or the Failure(s).
 &lt;param name=&quot;f&quot;&gt;The function wrapped in a Success or a Failure.&lt;/param&gt;
 &lt;param name=&quot;x&quot;&gt;The value wrapped in a Success or a Failure.&lt;/param&gt;
 &lt;returns&gt;A Success of the function applied to the value when both are Success, or the Failure(s) if more than one, combined with the Semigroup (++) operation of the Error type.&lt;/returns&gt;
</summary>
</member>
<member name="T:FSharpPlus.Data.Kleisli">
<summary>
 Basic operations on Kleisli
</summary>
</member>
<member name="M:FSharpPlus.Data.Free.liftF``3(``0)">
<summary>
 Lift any Functor into a Free structure
</summary>
</member>
<member name="M:FSharpPlus.Data.Free.iterM``5(Microsoft.FSharp.Core.FSharpFunc{``0,``4},FSharpPlus.Data.Free{``2,``3})">
<summary>
 Tear down a Free monad using iteration.
</summary>
</member>
<member name="M:FSharpPlus.Data.Free.fold``5(Microsoft.FSharp.Core.FSharpFunc{``0,``3},FSharpPlus.Data.Free{``1,``2})">
<summary>
 Folds the Free structure into a Monad
</summary>
</member>
<member name="T:FSharpPlus.Data.Free">
<summary>
 Basic operations on Free Monads
</summary>
</member>
<member name="M:FSharpPlus.Parsing.tryScanfn``5(Microsoft.FSharp.Core.PrintfFormat{``0,``1,``2,``3,``4})">
<summary>
 Gets a tuple with the result of parsing each element of a formatted text from the Console. Returns None in case of failure.
</summary>
</member>
<member name="M:FSharpPlus.Parsing.trySscanf``5(Microsoft.FSharp.Core.PrintfFormat{``0,``1,``2,``3,``4},System.String)">
<summary>
 Gets a tuple with the result of parsing each element of a formatted text. Returns None in case of failure.
</summary>
</member>
<member name="M:FSharpPlus.Parsing.tryParseArray``1(System.String[])">
<summary>
 Gets a tuple with the result of parsing each element of a string array. Returns None in case of failure.
</summary>
</member>
<member name="M:FSharpPlus.Parsing.scanfn``5(Microsoft.FSharp.Core.PrintfFormat{``0,``1,``2,``3,``4})">
<summary>
 Gets a tuple with the result of parsing each element of a formatted text from the Console.
</summary>
</member>
<member name="M:FSharpPlus.Parsing.sscanf``5(Microsoft.FSharp.Core.PrintfFormat{``0,``1,``2,``3,``4},System.String)">
<summary>
 Gets a tuple with the result of parsing each element of a formatted text.
</summary>
</member>
<member name="M:FSharpPlus.Parsing.parseArray``1(System.String[])">
<summary>
 Gets a tuple with the result of parsing each element of a string array.
</summary>
</member>
</members>
</doc>
